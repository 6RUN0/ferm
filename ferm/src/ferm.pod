#
# ferm pod manual file
#

#
# ferm, a firewall setup program that makes firewall rules easy!
#
# Copyright (C) 2001-2005  Auke Kok, Max Kellermann
#
# Comments, questions, greetings and additions to this program
# may be sent to <sofar@foo-projects.org>
#

#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

=head1 NAME

B<ferm> - a firewall rule parser for linux

=head1 SYNOPSYS

B<ferm> I<options> I<inputfiles>

=head1 DESCRIPTION

B<ferm> compiles ready to go firewall-rules from a structured
rule-setup. These rules will be executed by the preferred kernel
interface, such as iptables(8).

Besides just executing all rules in one command, the obvious gain
is the possibility to provide a structured description of a
firewall. No need anymore for tedious typing all firewalls into
custom scripts, you can now write logically and coherent rules
using a C-style nesting structure, and let B<ferm> create all
rules for you.

B<ferm> will also aid in modularizing firewalls, because it
creates the possibility to split up the firewall into several
different files, which can be reloaded at will, so you can
dynamically adjust your rules.

B<ferm>, pronounced "firm", stands for "For Easy Rule Making".

=head1 INTRODUCTION

Let's start with a simple example:

    chain INPUT {
        proto tcp ACCEPT;
    }

This will add a rule to the predefined input chain, matching and
accepting all tcp packets.  Ok, let's make it more complicated:

    chain (INPUT OUTPUT) {
	proto (udp tcp) ACCEPT;
    }

This will insert 4 rules, namely 2 in chain input, and 2 in chain
output, matching and accepting both udp and tcp packets.  Normally you
would type this:

   iptables -A INPUT -p tcp -j ACCEPT
   iptables -A OUTPUT -p tcp -j ACCEPT
   iptables -A INPUT -p udp -j ACCEPT
   iptables -A OUTPUT -p udp -j ACCEPT

Note how much less typing we need to do? :-)

Basically, this is all there is to it, although you can make it quite
more complex. Something to look at:

   chain INPUT policy ACCEPT {
       daddr 10/8 dport ! ftp goto mychain sport :1023 TOS 4 settos 8 mark 2;
       daddr 10/8 dport ftp DENY;
   }

My point here is, that *you* need to make nice rules, keep
them readable to you and others, and not make it into a mess.

It would aid the reader if the resulting firewall rules were placed
here for reference. Also, you could include the nested version with
better readability.

Try using comments to show what you are doing:

    # this line enables transparent http-proxying for the internal network:
    proto tcp if eth0 daddr ! 192.168.0.0/255.255.255.0
        dport http REDIRECT 3128;

You will be thankful for it later!

    chain INPUT policy ACCEPT {
        interface (eth0,ppp0) {
            # deny access to notorius hackers, return here if no match
            # was found to resume normal firewalling
            goto badguys;

            protocol tcp goto fw_tcp;
            protocol udp goto fw_udp;
        }
    }

The more you nest, the better it looks. Make sure the order you
specify is correct, you would not want to do this:

    chain FORWARD {
        proto ! udp DENY;
        proto tcp dport ftp ACCEPT;
    }

because the second rule will never match. Best way is to specify
first everyting that is allowed, and then deny everything else.
Look at the examples for more good snapshots. Most people do
something like this:

    proto tcp {
        dport (
            ssh http ftp
        ) ACCEPT;
        dport 1024:65535 ! syn ACCEPT;
        DROP;
    }

=head1 STRUCTURE OF A FIREWALL FILE

The structure of a proper firewall file looks like  simplified
C-code. Only a few syntactic characters are used in ferm-
configuration files. Besides these special caracters, ferm
uses 'keys' and 'values', think of them as options and
parameters, or as variables and values, whatever.

With these words, you define the characteristics of your firewall.
Every firewall consists of two things: First, look if network
traffic matches certain conditions, and second, what to do
with that traffic.

You may specify conditions that are valid for the kernel
interface program you are using, probably iptables(8). For
instance, in iptables, when you are trying to match tcp
packets, you would say:

    iptables --protocol tcp

In ferm, this will become:

    protocol tcp;

Just typing this in ferm doesn't do anything, you need to tell
ferm (actually, you need to tell iptables(8) and the kernel) what
to do with any traffic that matches this condition:

    iptables --protocol tcp -j ACCEPT

Or, translated to B<ferm>:

    protocol tcp ACCEPT;

The B<;> character is at the end of every ferm rule. Ferm ignores line
breaks, meaning the above example is identical to the following:

    protocol tcp
      ACCEPT;

Here's a list of the special characters:

=over 8

=item B<;>

This character finalizes a rule.

Separated by semicolons, you may write multiple rules in one line,
although this decreases readability:

    protocol tcp ACCEPT; protocol udp DROP;

=item B<{}>

The nesting symbol defines a 'block' of rules.

The curly brackets contain any number of nested rules. All matches
before the block are carried forward to these.

The closing curly bracket finalizes the rule set. You should not write
a ';' after that, because that would be an empty rule.

Example:

    chain INPUT proto icmp {
        icmp-type echo-request ACCEPT;
        DROP;
    }

This block shows two rules inside a block, which will both be merged
with anything in front of it, so you will get two rules:

    iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
    iptables -A INPUT -p icmp -j DROP

There can be multiple nesting levels:

    chain INPUT {
        proto icmp {
            icmp-type echo-request ACCEPT;
            DROP;
        }
        daddr 172.16.0.0/12 REJECT;
    }

Note that the 'REJECT' rule is not affected by 'proto icmp', although
there is no ';' after the closing curly brace. Translated to iptables:

    iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
    iptables -A INPUT -p icmp -j DROP
    iptables -A INPUT -d 172.16.0.0/12 -j REJECT

=item B<%>

Variable expansion. Replaces '%FOO' by the value of the variable
'FOO'.

To set variables, write:

    set IF eth0
    set %IF ACCEPT
    set TARGET %IF

resulting in:

    %IF = eth0
    %eth0 = ACCEPT
    %TARGET = eth0

If you want to put multiple arguments into a variable, you should do
it like this:

    set %IFS = (eth0 eth1 ppp0)

This way, ferm will recognize it being a list of values (an "array").

=item B<()>

The array symbol. Using the parentheses, you can define
a 'list' of values that should be applied for the key to the
left of it.

Example:

    protocol ( tcp udp icmp )

this will result in three rules:

    ... -p tcp ...
    ... -p udp ...
    ... -p icmp ...

Only values can be 'listed', so you cannot do something like this:

    proto tcp ( ACCEPT LOG );

but you can do this:

    chain (INPUT OUTPUT FORWARD) proto (icmp udp tcp) DENY;

(which will result in nine rules!)

Values are separated by spaces. The array symbol is both left- and
right-associative, in contrast with the nesting block, which is
left-associative only.

=item C< # >

The comment symbol. Anything that follows this symbol up to
the end of line is ignored.

=back


=head2 Keywords

In the previous section, we already introduced some basic keywords
like "chain", "protocol" and "ACCEPT". Let's explore their nature.

There are three kinds of keywords:

=over 8

=item

B<location> keywords define where a rule will be created. Example:
"table", "chain".

=item

B<match> keywords perform a test on all passing packets. The current
rule is without effect if one (or more) of the matches does not
pass. Example: "proto", "daddr".

Most matches are followed by a parameter: "proto tcp", "daddr
172.16.0.0/12".

=item

B<target> keywords state what to do with a packet. Example: "ACCEPT",
"REJECT", "goto".

Some targets define more keywords to specify details: "REJECT
reject-with icmp-net-unreachable".

=back

Every rule consists of a B<location> and a B<target>, plus any number
of B<matches>:

    table filter                  # location
    proto tcp dport (http https)  # match
    ACCEPT;                       # target

Strictly speaking, there is a fourth kind: B<ferm> keywords (which
control ferm's internal behaviour), but they will be explained later.


=head2 Parameters

Many keywords take parameters. These can be specified as literals,
variable references or lists (arrays):

    proto udp
    saddr %TRUSTED_HOSTS;
    proto tcp dport (http https ssh);

Some of them can be negated (lists cannot be negated):

    proto !esp;
    proto udp dport !domain;

Keywords which take no parameters are negated by a prefixed '!':

    proto tcp !syn;

Read iptables(8) to see where the B<!> can be used.


=head2 Option keys

Using B<option> keys alter the behaviour of B<ferm>; they
can be used to e.g. clear chains before use, or turn off certain
sanity checks.

Example:

  option verbose

This option makes B<ferm> show a lot of information about what
it is doing.


=head2 keywords

To make life easy, B<ferm> allows you to use shorthands for
most keywords. A list of shorthand notations is available at the end
of this section.

What kind of value you provide for a keyword depends on the 
keyword entirely, e.g. 'protocol' expects 'tcp', 'udp' or 'icmp',
'log-prefix' expects a value like '"whoops, someone rang the
doorbell"' and 'destination-port' can accept values like 'http',
'80' or '0:1023'. Take a look at the kernel backend program
manual for possible values and how they look like.

Note you may put a value in single quotes or double quotes,
if this may be required because a value contains spaces:

    log-prefix "Dropped tcp package: "

Please keep in mind that some characters have special meaning,
so it might be wise to refrain from using any other character
then letters and digits and spaces unless you need them and
know what you're doing. Take a look at B<VARIABLES> and
B<SHELL ESCAPES> for more information about that.

=over 8

=item B<chain [chain-name]>

Specifies a chain that this rule will be inserted to. this
is a required key for any rule. Chains can be
built in, like C<input>, C<output> or C<forward>, or user-defined
chains.

=item B<interface [interface-name]>

Define the interface name, your outside network card, like eth0,
or dialup like ppp1, or whatever device you want to match for
passing packets. It is equivalent to the C<-i> switch in
iptables(8).

=item B<outerface [interface-name]>

Same as interface, only for matching the outgoing interface
for a packet, as in iptables(8).

=item B<protocol [protocol-name|protocol-number]>

Currently supported by the kernel are tcp, udp and icmp, or
their respective numbers.

=item B<saddr|daddr [address-spec]>

Matches on packets originating from the specified address (saddr) or
targeted at the address (daddr).

=item B<sport|dport [port-spec]>

Matches on packets on the specified TCP or UDP port. "sport" matches
the source port, and dport matches the destination port.

This match can be used only after you specified "proto tcp" or "proto
udp", because only these two protocols actually have ports.

Here are some examples of valid addresses:

    192.168/8 (identical to the next one:)
    192.168.0.0/255.255.255.0
    my.domain.com

And some examples of valid ports/ranges:

    80
    http
    ssh:http
    0:1023        which is equivalent to     :1023
    1023:65535    which is equivalent to     1023:65535

=item B<icmptype [type]>

To specify an icmp message type. Can be numbers, but refer
to the manual of the kernel program to retreive a list,
for iptables use "iptables -p icmp C<-h>". Examples: ping, pong.

=item B<tos [value]>

Matches a packet on the specified TOS-value. See settos for
values.

=item B<settos [value]>

Set the tcp package Type Of Service bit to this value.
This will be used by whatever traffic scheduler is willing to,
mostly your own linux-machine, but maybe more. The original
tos-bits are blanked and overwritten by this value. Possible
values are (look in the shorthands for more, and easier
values) :

02 04 08 10

=item B<setftos [value]>

Set TOS field in packet header to value. This value can be
in decimal (ex: 32) or in hex (ex: 0x20)

=item B<mark [value]>

matches packets based on their mark-value

=item B<setmark [value]>

Sets the mark-value for a packet, use with the MARK target in iptables

=item B<syn>

Specify that the SYN flag in a tcp package should be matched,
which are used to build new tcp connections. You can identify
incoming connections with this, and decide wether you want
to allow it or not. Packets that do not have this flag are
probably from an already established connection, so it's
considered reasonably safe to let these through.

=item B<fragment>

Specify that only fragmented IP packets should be matched.
When packets are larger that the maximum packet size your
system can handle (called Maximum Transmission Unit or MTU)
they will be chopped into bits and sent one by one as single
packets. See ifconfig(8) if you want to find the MTU for
your system (the default is usually 1500 bytes).

Fragments are frequently used in DOS attacks, because there
is no way of finding out the origin of a fragment packet.

=item B<policy [policy]>

Specifies the default policy for the current chain. Can be
either of the standard actions (ACCEPT, DENY, REJECT, MASQ
and REDIRECT). A packet that matches no rules will be treated
as specified by the policy. You can't specify chain names
here. Only the predefined (built-in) chains have policies.

To avoid ambiguity, always specify the policies of all
predefined chains explicitly.

=item B<log>

Log all packets that match this rule in the kernel log. Be
carefull with log flooding. Note the difference with B<LOG>
in iptables! See B<LOG> as well. In iptables, this makes a
copy of the current rule, and inserts it with the LOG target
instead of any other specified target. 

See also B<log-[level|prefix|tcp-sequence|tcp-options|ip-options]>

=item B<goto [chain]>

Specify that matching packets should jump to this chain, only user
defined chains are valid jump targets.

=item B<LOG>

Identical to the 'LOG' target in iptables, logs any packet that
matches, but doesn't do anything else to it. Only valid for
iptables, otherwise use 'log'. See B<log> and also
B<log-[level|prefix|tcp-sequence|tcp-options|ip-options]>.

=item B<ACCEPT>

Accepts matching packets.

=item B<REJECT>

Rejects matching packets.

=item B<DENY>

Denies matching packets.

=item B<MASQ toports [port|portrange]>

Masquerades matching packets. Optionally followed by a port or
port-range for iptables. Specify as "123", "123-456" or "123:456".
The port range parameter specifies what local ports masqueraded
connections should originate from. Note you need to specify the
'to' word here.

=item B<RETURN>

Returns to the parent chain where the current chain was called
if the packet matches.

=item B<REDIRECT [to|toports] [port|portrange]> 

Allows transparent proxying when rule matches, the port that is
redirected to must immediately follow this keyword. The target
may also be an IP-number in case you are using iptables(8), so
something like "REDIRECT 192.168.0.5:21" is valid there.

=item B<SNAT|DNAT to [ip-address|ip-range|ip-port-range]>

Allows source/destination address translation, only valid for
iptables(8), requires an ip-number, range or ip/port value.

=item B<TOS>

Changes the packets TOS-field according to the set-tos parameter
specified, only valid for iptables.

=item B<FTOS>

Set TOS field in packet header with setftos parameter.

=item B<TTL>

The ttl-target is for changing ttl values

=item B<table [table-name]>

Selects this table for the rule. Valid table names are "filter",
"nat" and "mangle". If you don't specify any table, the default
table "filter" is used.

=item B<reject-with [value]>

Rejects a packet with an ICMP value type message.

=item B<limit [value]>

Limits these type of packets to a maximim.

=item B<iplimitabove [value]>

Limits a certain IP list a number of connections.

=item B<iplimitmask [value]>

Specifies the mask to use for iplimitabove.

=item B<psdweightthreshold [value]>

Specifies the port scan weight threshold

=item B<psddelaythreshold [value]>

Specifies the delay weight for port scans

=item B<psdloportsweight [value]>

Specifies the weight for low ports in the port scan detection algorithm

=item B<psdhiportsweight [value]>

Specifies the weight for high ports in the port scan detection algorithm

=item B<ttl [value]>

Matches the ttl for value

=item B<ttl-[eq|lt|gt] [value]>

Matches the ttl value when equal, smaller or larger than value

=item B<ttl-[set|dec|inc] [value]>

Sets, decreases or increases the ttl value

=item B<length [[value]|[value:value]]>

Specify a certain packet length to match, may be a range of lengths

=item B<burst [value]>

Limits bursts of these packets.

=item B<mac [value]>

Matches packets originating from these mac-addresses.

=item B<state [value]>

Matches packets with this state. The value may be specified as a ferm
array: "(ESTABLISHED RELATED)" or a single value.

=item B<tcp-flags [!] [flagmask] [flagmatch]>

Specify tcp-flags, the B<!> is optional and has to precede the mask,
mask and match are mandatory. The list of mask or match flags may be
specified as a ferm array: "(SYN ACK RST)" or a single value.

=item B<tcp-option [value]>

Specify a tcp-option for this rule.

=item B<log-[level|prefix]>

Specifies several the log level and syslog prefix string.

=item B<log-|tcp-sequence|tcp-options|ip-options]>

Specifies several extra tcp/ip options.

=item B<[u|g|p|s]id-owner [value]>

Matches packets originating from this User, Group, Pid or Session ID.

=item B<set [name] [value]>

Set variable "name" to value "value", you can dereference the variables
by "%name". You may also put variables within B<set> statements.

=back

=head1 VARIABLES

ferm also supports internal variables. This may come in handy if you
wish to define often used parameters in advance, making the ferm
configuration files even more easy to understand. 

Setting variables is very easy with the B<set> command. Here's some
examples:

    set EXTERAL_IP 111.22.33.44
    set INTERNAL_IP '10.0.0.1'

You may afterwards refer to them like this:

    chain input daddr ! %EXTERNAL_IP DROP;

The value of the variable will then be inserted into the rule and
passed to the firewall program.

the B<set> command can actally be abused even more, since the following
statements also work:

    set A "1"
    set B %A
    set %A 2

After these statements, variable %A yields value "1", variable %B holds 
the value "1", and the variable %1 holds the value "1" also.

More importantly, these variables can be used to store arrays of
values:

    set DNSSERVERS (111.2.33.1 111.2.33.2)

When this variable is inserted into a configuration file, the rule that
it applies to will automatically be split up into two different firewall
rules for each IP number given in the array.

Here's some even more complicated stuff that works:

    set INTERNALINTERFACES (eth0 eth1 eth2)
    set EXTERNALINTERFACES (ppp0 tunl0)
    set INTERFACES (%INTERNALINTERFACES %EXTERNALINTERFACES lo)


=head1 SHELL ESCAPES

Ferm supports shell escaping in two ways. First, you may insert a
shell escaped string into a B<set> command, second, you may insert
a shell escaped string into any place of a value.

There is a fundamental difference in this. Ferm will handle shell
escapes itself when they are used in a B<set> construction, so the
variable then contains the value that was returned from the shell
escape. You may later refer to this value again without the command
being executed again.

When you use a shell escaped string as a value without it being
in a B<set> statement, the exact string is just copied in the
generated rule, and when parsing is finished, ferm will call
the shell with the entire rule, and thus the shell escaped string.
Only at this moment, the shell will execute the string and insert
the value back into the kernel interface program. Thus, ferm will
never see the real value of that.

Examples:

    set DNSSERVERS `grep nameserver /etc/resolv.conf | awk '{print $2}'`
    chain INPUT proto tcp saddr %DNSSERVERS ACCEPT;

This way, ferm will interpret the value for DSSERVERS itself, put
a separating comma between multiple values if needed, and store
this information in the variable DNSSERVERS. The output will be
like:

    iptables -t filter -A INPUT -p tcp -s 192.168.0.1 -j ACCEPT
    iptables -t filter -A INPUT -p tcp -s 192.168.0.2 -j ACCEPT

Otherwise, when you include a shell escape as a regular value
in between other ferm-statements:

    chain input proto tcp saddr `grep nameserver /etc/resolv.conf | awk '{print $2}'` ACCEPT;

The shell escape is not parsed directly, but passed along with the, e.g.
B<iptables> command, and subsequently, the shell will insert whatever
that value may become itself:

    iptables -t filter -A INPUT -p tcp -d `grep nameserver /etc/resolv.conf | awk '{print $2}'` -j ACCEPT

Note that if the shell escape here yields more lines, something could
go wrong here easily. You are warned! Better not make ferm SUID too
I guess ;-)

=head1 SHORTHANDS

Here's a complete list of possible shorthands, just
to reduce the amount of typing:

=over 4

=item interface:

if

=item outerface:

of

=item protocol:

proto

=item fragment:

frag

=item ACCEPT:

accept

=item DENY:

deny, DROP, drop

=item REJECT:

reject

=item MASQ:

masq

=item RETURN:

return

=item REDIRECT:

redirect, PROXY, proxy

=item MARK:

mark

=item QUEUE:

queue

=item SNAT:

snat

=item DNAT:

dnat

=item goto:

to, jump

=item icmptype

icmp-type

=item tcp-option:

tcpoption

=item mac:

mac-source, macsource

=item iplimitabove:

ip-limit-above

=item iplimitmask

ip-limit-mask

=item burst:

limit-burst, limitburst

=item uid-owner:

uidowner, uid

=item gid-owner:

gidowner, gid

=item pid-owner:

pidowner, pid

=item sid-owner:

sidowner, sid

=item psdweightthreshold:

psd-weight-threshold

=item psddelaythreshold:

psd-delay-threshold

=item psdloportsweight:

psd-lo-ports-weight

=item psdhiportsweight:

psd-hi-ports-weight

=item log-level:

loglev

=item log-prefix:

logprefix

=item log-tcp-sequence:

logseq

=item log-tcp-options:

logtcpopt

=item log-ip-options:

logipopt

=item reject-with:

rejectwith

=item setmark

set-mark

=item tos/settos-values:

The following Type Of Services values may be given:

    mincost min-cost 2 02 0x02

    reliability reliable 4 04 0x04

    max-throughput maxthroughput 8 08 0x08

    lowdelay interactive min-delay 10 0x10

    clear 0 00 0x00

=item setftos

set-ftos

=back

=head1 OPTIONS

Options can be specified with the "option" keyword, which
can be defined anywhere within the document. Although
that may be fine, you almost allways want to define
them at the beginning of your document, because the
behaviour changes at the moment they are specified.

All options can also be specified on the command line, which
has a few more available. The equivalent for the commandline
options that are also available in the firewall file is mentioned
in the firewall file options section.

=head2 Command line options

=over 12

=item B<--noexec>

Do not execute the iptables(8) commands, but skip instead. This way
you can parse your data, use B<--lines> to view the output.

=item B<--lines>

Show the firewall lines that were generated from the rules. They
will be shown just before they are executed, so if you get error
messages from iptables(8) etc., you can see which rule caused
the error.

=item B<--verbose>

Shows some more details of the stages of execution of the program.

=item B<--debug>

Shows even more details of what ferm is doing while parsing
the rules. The debug info is put between the output for
clearity and commented.

=item B<--help>

Show a brief list of available commandline options.

=item B<--version>

Shows the version number of the program.

=item B<--location [/path/to/filename]>

Explicitly define the exact name and location of the
kernel backend program, for the paranoid people out there.

=item B<--automod>

Automatically insert the correct module parameter when using iptables,
making the B<module> parameter unnecessary

=back

=head2 Firewall file options

=over 8

=item B<option clearall>

Clears the entire firewall, deletes all user chains and flushes
the built in chains. Does not alter policies.

=item B<option flushall>

Flushes all chains but does not delete them.

=item B<option flushchains>

Flushes any chain which is defined in the setup, even
built-in chains are flushed when referred.

=item B<option createchains>

Creates any chain which is referred to, even when no rule is
specified for the chain, but is only referred by with a 
"goto" keyword.

=item B<option automod>

Automatically insert the correct module parameter when using iptables,
making the B<module> parameter unnecessary

=back


=head1 SEE ALSO

iptables(8)


=head1 NOTES

A good firewall is not the only step in security, even the
firewall may be insecure, or someone breaks into your house
and steals the hard disk out of your PC. Do not rely on this
firewall tool for the use of mission critical or confidential
data. It is not fit for such a purpose!

Instead, use this tool to expand your current use of iptablws(8)
and routing, create a flexible firewall and look out for
anything suspicious. Be carefull with open ports and servers,
always get the latest, patched versions. Read more about
firewalls before experimenting, you are warned! You might
also read the COPYING file provided with the package or
visit www.gnu.org to find more about the license.


=head1 EXAMPLES

The package comes with a directory full of goodies (examples)
that you can try, adjust for your system or just read if
you want to understand the syntax and it's possibilities.
Look in the "examples" directory.


=head1 REQUIREMENTS

=head2 Operating system

The Operating system currently supported is only linux, although
it may be possible to port this program to support FreeBSD or
SOLARIS firewall systems, provided they supply a similar
firewalling scheme. (Does anybody known about that?)

=head2 Software/packages

Required are 2 packages: Perl5, under which this B<ferm>
runs, and one of the kernel firewall programs, suited for
your system and kernel version.

=head2 Kernel

The respective required kernel versions for the kernel firewall
programs (iptables(8)) is also needed. This means you have to have a
kernel which can use the firewalling thing, something you might have
to compile a kernel for, or set some switches in /proc. Look at the
man pages of those kernel programs for more information.


=head1 RESTRICTIONS

B<ferm> allows almost anything the used firewall program
allows, so go ahead and specify complex port ranges, icmp
by number or worse. Just be warned.

Although quite sophisticated, the kernel interface program
iptables(8) are very limited in some respects.
B<ferm> is only an interface to improve the handling of
these programs, and is therefore limited by the possibilities
of these programs.


=head1 BUGS

Several nasty cleanups are not done well, which may result
in surviving data. Tried to remove all of them but suspect
more of them to occur.


=head1 COPYRIGHT

Copyright (C) 2001-2005 Auke Kok <sofar@foo-projects.org>, Max
Kellermann <max@foo-projects.org>

=head1 LICENSE

B<ferm> is released under the GNU General Public License, see the
COPYING file that came with the package or visit www.gnu.org.

This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.

=head1 AUTHOR

Auke Kok <sofar@foo-projects.org>, Max Kellermann
<max@foo-projects.org>

=cut


