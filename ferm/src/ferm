#!/usr/bin/perl

#
# ferm, a firewall setup program that makes firewall rules easy!
#
# Copyright (C) 2001-2003  Auke Kok
#
# Comments, questions, greetings and additions to this program
# may be sent to <sofar@foo-projects.org>
#

#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

use strict;
use IO::File;
use Getopt::Long;
use Pod::Usage;

use vars qw($VERSION $DATE);

$VERSION = '1.1+cvs';
$DATE = '19 oct 2004';

# global data vars
my @rules;     # will contain all rules
my %tables;    # chain box for iptables
    $tables{'filter_input'} = 0;
    $tables{'filter_forward'} = 0;
    $tables{'filter_output'} = 0;
    $tables{'nat_prerouting'} = 0;
    $tables{'nat_postrouting'} = 0;
    $tables{'nat_output'} = 0;
    $tables{'mangle_prerouting'} = 0;
    $tables{'mangle_output'} = 0;
               # 0=made;1=policy set;2=flushed;3=all
my %option;    # some configuration options
my %vars;      # holds variable data

use vars qw($script);
use vars qw($verbose $debug);

use subs qw(open_script);

# Get command line stuff
{
    my ($opt_noexec, $opt_lines, $opt_location, $opt_clearall, $opt_flushall,
        $opt_createchains, $opt_flushchains, $opt_help, $opt_automod,
        $opt_version, $opt_use);

    Getopt::Long::Configure('bundling', 'auto_help', 'no_ignore_case',
                            'no_auto_abbrev');

    GetOptions('noexec|n' => \$opt_noexec,
               'lines|l' => \$opt_lines,
               'verbose|v' => \$verbose,
               'debug|d' => \$debug,
               'location=s' => \$opt_location,
               clearall => \$opt_clearall,
               flushall => \$opt_flushall,
               createchains => \$opt_createchains,
               flushchains => \$opt_flushchains,
               'help|h' => \$opt_help,
               automod => \$opt_automod,
               'version|V' => \$opt_version,
               'use=s' => \$opt_use,
              );

    pod2usage(-exitstatus => 0)
      if defined $opt_help;

    if (defined $opt_version) {
        printversion();
        exit 0;
    };

    $option{'noexec'} = (defined $opt_noexec);
    $option{'lines'} = (defined $opt_lines);
    $option{'clearall'} = (defined $opt_clearall);
    $option{'flushall'} = (defined $opt_flushall);
    $option{'flushchains'} = (defined $opt_flushchains);
    $option{'createchains'} = (defined $opt_createchains);
    $option{'automod'} = (defined $opt_automod);

    print STDERR "Ignoring the obsolete --use/-s option\n"
      if defined $opt_use;

    if (defined $opt_location) {
        $option{'location'} = $opt_location;
        if ( ! -X $option{'location'}) {
            mydie("Specified location is not executable or does not exist! Exiting");
        }
    }
}

$verbose && printversion();

mydie("Specify only one ferm script")
  unless @ARGV == 1;

open_script($ARGV[0]);

# option checks
if (defined $option{location}) {
    mydie("Specified location is not executable or does not exist! Exiting")
      unless -X $option{'location'};
} else {
    # set a default location
    $option{location} = 'iptables';
}

# clearing and flushing needs to be done first:
$option{'clearall'} && clearall();
$option{'flushall'} && flushall();


# parse all input recursively
$verbose && print "Parsing files\n";
enter(0);

# and execute all generated rules
$verbose && print "\nExecuting rules\n";
foreach my $rr (@rules) {
    $rr =~ s/ $//g;
    if ($option{'lines'} || $debug ) {
        print $rr; };
    if (!$option{'noexec'} ) {
        for ($rr) {
            !/^#/ && do {
                if ((!$option{'lines'}) && $verbose) {print "."};
                system ($rr);
            };
        };
    };
}

$verbose && print "Done, exiting\n";
exit 0;

# end of program execution!


# funcs

sub printversion {
    print "ferm $VERSION, $DATE\n";
    print "Copyright (C) 2001-2003 - Auke Kok, released under the GPLv2\n";
    print "See the included COPYING file for license details.\n";
}


sub mydie {
    print STDERR @_;
    print STDERR "\n";
    exit 1;
}


sub error {
    # returns a nice formatted error message, showing the
    # location of the error.
    my $tabs = 0;
    my @lines;
    my $l = 0;
    my @words = @{$script->{past_tokens}};

    for my $w ( 0 .. $#words ) {
        if ($words[$w] eq "\x29")
            { $l++ ; $lines[$l] = "    " x ($tabs-- -1) ;};
        if ($words[$w] eq "\x28")
            { $l++ ; $lines[$l] = "    " x $tabs++ ;};
        if ($words[$w] eq "\x7d")
            { $l++ ; $lines[$l] = "    " x ($tabs-- -1) ;};
        if ($words[$w] eq "\x7b")
            { $l++ ; $lines[$l] = "    " x $tabs++ ;};
        if ( $l > $#lines ) { $lines[$l] = "" };
        $lines[$l] .= $words[$w] . " ";
        if ($words[$w] eq "\x28")
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x29") && ($words[$w+1] ne "\x7b"))
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if ($words[$w] eq "\x7b")
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x7d") && ($words[$w+1] ne "\x7d"))
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x3b") && ($words[$w+1] ne "\x7d"))
            { $l++ ; $lines[$l] = "    " x $tabs ;}
        if ($words[$w-1] eq "option")
            { $l++ ; $lines[$l] = "    " x $tabs ;}
    }
    my $start = $#lines - 4;
    if ($start < 0) { $start = 0 } ;
    print STDERR "Error in $script->{filename} line $script->{line}:\n";
    for $l ( $start .. $#lines)
        { print STDERR $lines[$l]; if ($l != $#lines ) {print STDERR "\n"} ; };
    print STDERR "<--\n";
    mydie(@_);
}

sub warning {
    print STDERR "Warning in $script->{filename} line $script->{line}: "
      . (shift) . "\n";
}

sub tokenize_string {
    # split the an input string into words
    my ($string) = @_;

    my @ret;

    foreach my $word ($string =~ m/(\x22[^\x22]+\x22|\x27[^\x27]+\x27|\x60[^\x60]+\x60|!|,|[0-9a-zA-Z\x23-\x26\x2a\x2b\x2d-\x3a\x3c-\x7a\x7c\x7e\x7f]+|\x28|\x29|\x7b|\x7d|\x3b)/g) {
        # explanation of all sections:
        # \x22[^\x22]+\x22 == "*"
        # \x27[^\x27]+\x27 == '*'
        # \x60[^\x60]+\x60 == `*`
        # [0-9a-zA-Z\x23-\x26\x2a-\x3a\x3c-\x7a\x7c\x7e\x7f]+
        #        == anything which is not one of these:
        # \x28 == (
        # \x29 == )
        # \x7b == }
        # \x7d == {
        # \x3b == ;

        $word =~ s/^(["'])(.*)\1$/$2/s;

        push @ret, $word;
    }

    return @ret;
}

sub setvar {
    my $vname = shift;
    my $vval = shift;

    for ($vval) {
        /^\x60/ && do {
            my $db;
            if ($debug) {
                $db = "# Executing backticks: $vval "; };
            # change all ' to \'
            $vval =~ s/'/\\'/g;
            # change `.....` to qx'.....' to prevent perl interpretation
            $vval =~ s/^\x60(.*)\x60$/qx'$1'/;
            $vval = eval($vval);
            # change newlines to comma's, omitting the last newline char
            $vval =~ s'\n$'';
            $vval =~ s'\n','g;
            if ($debug) {
                push @rules, "$db -\> $vval\n"; };
        };
        /^\x22/ && do {
            $vval =~ s/\x22//g;
        }
    }

    $vars{$vname} = $vval;
}

sub next_array_token {
    my $array = shift;
    shift @$array;
}

sub prepare_tokens {
    return
      unless defined $script;

    my $tokens = $script->{tokens};
    die unless ref $tokens eq 'ARRAY';

    while (@$tokens == 0) {
        my $line = $script->{handle}->getline;
        unless (defined $line) {
            # end of file, switch to the next in the chain and recurse
            # to read tokens from this file
            $script = $script->{parent};
            return prepare_tokens();
        }

        $script->{line} ++;

        # chop comments:
        $line =~ s/#.*$//g;

        my @line = tokenize_string($line);

        # look at the first word, then decide what to do. some special
        # keywords are handled here, everything else gets added to @tokens
        if ($line[0] eq 'option') {
            # option: edit the %option hash
            shift @line;
            my $name = shift @line;
            my $value = shift @line;

            unless (defined $value) {
                $value = 1;
            } elsif ($value eq 'off') {
                $value = undef;
            }

            if ($value and $name =~ /^(?:ipchains|iptables|ipfwadm)$/) {
                print STDERR "The options ipchains, iptables and ipfwadm are obsolete, ignoring them\n";
            } else {
                $option{$name} = $value;
            }
        } elsif ($line[0] eq 'set') {
            # set: set a variable
            shift @line;
            my $name = getvar(\&next_array_token, \@line);
            my $value = getvalues(\&next_array_token, \@line,
                                 empty_allowed => 1);

            if (@line and $line[0] eq ',') {
                warning('Arrays without parantheses are deprecated');

                $value = [ $value ]
                  unless ref $value;

                do {
                    shift @line;
                    my $v = getvalues(\&next_array_token, \@line);
                    push @$value, ref $v ? @$v : $v;
                } while (@line and $line[0] eq ',');
            }

            error('spare tokens after "set"')
              if @line;

            setvar($name, $value);
        } elsif ($line[0] eq 'include') {
            # include: include another file
            shift @line;

            my $filename = shift @line;

            # check if the file exists
            mydie("No such file in $script->{filename} line $script->{line}: $filename")
              unless -f $filename;

            # prevent opening the same file twice at a time
            for (my $s = $script; defined $s; $s = $s->{parent}) {
                mydie("Circular reference in $script->{filename} line $script->{line}: $filename")
                  if $s->{filename} eq $filename;
            }

            # open it, put it on stack
            open_script($filename);
            last;
        } else {
            # the next parser stage eats this
            push @$tokens, @line;
        }
    }

    return 1;
}

sub open_script {
    my $filename = shift;

    my $handle = new IO::File("<$filename");
    mydie("Failed to open $filename: $!")
      unless defined $handle;

    $script = { filename => $filename,
                handle => $handle,
                line => 0,
                past_tokens => [],
                tokens => [],
                parent => $script,
              };

    prepare_tokens();

    return $script;
}

sub next_token {
    # get a token
    prepare_tokens();

    return
      unless defined $script;

    my $tokens = $script->{tokens};
    die unless ref $tokens eq 'ARRAY';

    return
      unless @$tokens;

    my $token = shift @$tokens;

    # update $script->{past_tokens}
    my $past_tokens = $script->{past_tokens};
    die unless ref $past_tokens eq 'ARRAY';

    if (@$past_tokens and
        ($past_tokens->[@$past_tokens - 1] eq '}' or
         $past_tokens->[@$past_tokens - 1] eq ';')) {
        # now this is tricky: $script->{past_tokens} is used in error
        # messages. in the following lines, we filter out everything
        # which has become irrelevant for error messages,
        # i.e. previous (completed) commands

        my $t = pop @$past_tokens;

        # track the current level - a '}' means one level up (we are
        # going backwards)
        my $level = $t eq '}' ? 1 : 0;

        while (@$past_tokens and $level >= 0) {
            $t = pop @$past_tokens;

            if ($level == 0 and ($t eq '}' or $t eq ';')) {
                # don't delete another command
                push @$past_tokens, $t;
                last;
            } elsif ($t eq '}') {
                # one level up
                $level++;
            } elsif ($t eq '{') {
                # one level down. stop here if we're already at level
                # zero
                if ($level == 0) {
                    push @$past_tokens, $t;
                    last;
                }

                $level--;
            }
        }
    }

    push @$past_tokens, $token;

    # return
    return $token;
}

sub require_next_token {
    # require that another token exists, and that it's not a "special"
    # token, e.g. ";" and "{"
    my $code = shift || \&next_token;

    my $token = &$code(@_);

    error('unexpected end of file')
      unless defined $token;

    error("unexpected '$token'")
      if $token =~ /^[;{}]/;

    return $token;
}

sub variable_value {
    # determine the value of a variable, die if the variable is
    # unknown
    my $name = shift;

    error("undefined variable: $name")
      unless exists $vars{$name};

    return $vars{$name};
}

sub string_variable_value {
    # determine the value of a variable, die if the value is an array
    my $name = shift;
    my $value = variable_value($name);

    error("variable '$name' must be a string, is an array")
      if ref $value;

    return $value;
}

sub resolve_variable_refs {
    # resolve all variable references in the string - may be an array!
    my $token = shift;

    if ($token =~ /^\%([0-9a-zA-Z\x2d\x5f]+)$/) {
        # if the token only of the reference, return the pure value
        return variable_value($1);
    } else {
        # a reference in the middle of the string. replace, but only
        # allow string variables, no arrays here
        $token =~ s/\%([0-9a-zA-Z\x2d\x5f]+)/string_variable_value($1)/eg;

        return $token;
    }
}

sub getvalues {
    my ($code, $param) = (shift, shift);
    my %options = @_;

    # returns the next parameter, which may either be a scalar or an
    # array
    my $token = require_next_token($code, $param);

    if ($token eq '(') {
        # read an array until ")"
        my @wordlist;

        for (;;) {
            $token = getvalues($code, $param,
                               comma_allowed => 1);

            unless (ref $token) {
                last if $token eq ')';

                if ($token eq ',') {
                    warning('Comma within arrays is deprecated, please use only a space');
                    next;
                }

                error('items cannot be negated in a array')
                  if $token eq '!';

                push @wordlist, $token;
            } elsif (ref $token eq 'ARRAY') {
                push @wordlist, @$token;
            } else {
                error('unknown toke type');
            }
        }

        error('empty arrays are not allowed')
          unless @wordlist or $options{empty_allowed};

        return @wordlist == 1
          ? $wordlist[0]
            : \@wordlist;
    } elsif ($token eq '!') {
        $token = getvalues($code, $param);

        error('it is not possible to negate an array')
          if ref $token;
        error('double negation is not allowed')
          if $token eq '!';

        return '! ' . $token;
    } elsif ($token =~ /^.+,.+$/) {
        warning('Arrays within a string are deprecated, please use parantheses');

        my @array = map {
            my $value = resolve_variable_refs($_);
            ref $value ? @$value : $value;
        } split(/,/, $token);

        return \@array;
    } elsif ($token eq ',') {
        return $token
          if $options{comma_allowed};

        error('comma is not allowed here');
    } else {
        return resolve_variable_refs($token);
    }
}

sub getvar {
    # returns the next parameter, but only allow a scalar
    my $token = getvalues(@_);

    error('array not allowed here')
      if ref $token;

    return $token;
}


sub to_array {
    # returns the specified value as an array. dereference arrayrefs
    my $value = shift;
    die unless wantarray;
    die if @_;
    unless (ref $value) {
        return $value;
    } elsif (ref $value eq 'ARRAY') {
        return @$value;
    } else {
        die;
    }
}

sub is_netfilter_builtin_target {
    my $target = shift;

    die unless defined $target and length $target;

    return $target =~ /(?:ACCEPT|DROP|RETURN|QUEUE
                         |BALANCE|CLASSIFY|CLUSTERIP|CONNMARK
                         |DNAT|DSCP|ECN|LOG|MARK|MASQUERADE
                         |MIRROR|NETMAP|REDIRECT|REJECT|ROUTE
                         |SNAT|TCPMSS|TOS|TRACE|TTL|ULOG
                       )/x;
}

sub shell_escape {
    my $token = shift;
    return $token
      if $token =~ /^\`.*\`$/;
    $token =~ s/'/\\'/g;
    $token = '\'' . $token . '\''
      if $token =~ /[\s\"\\]/s;
    return $token;
}

sub shell_append {
    my $ref = shift;

    foreach (@_) {
        $$ref .= shell_escape($_) . ' ';
    }
}

sub tables {
    my $rule = shift;
    my %rule = %$rule;

    # iptables, for 2.3/2.4 kernels
    my $rr = "";
    my $rrr = "";

    # pre-setup rrr for creation of chains
    if (!defined $rule{'table'} ) {
         $rule{'table'} = 'filter';}
    $rrr .= "$option{'location'} -t " . $rule{'table'} . " ";

    # in iptables, built-in chains are UPPERCASE
    for( $rule{'chain'} ) {
        /^input$|^forward$|^output$|^prerouting$|^postrouting$/ && do {
            $rule{'chain'} = uc $rule{'chain'} ; } };

    # should we set a policy?
    if ( exists $rule{'policy'} ) {
        for ( $rule{'chain'} ) {
            /^INPUT$|^FORWARD$|^OUTPUT$|^PREROUTING$|^POSTROUTING$/ && do {
                if ( ! ($tables{$rule{'table'} . '_' . lc $rule{'chain'}} & 1) ) {
                    my $policy = $rule{policy};
                    $policy = 'DROP'
                      if $policy eq 'REJECT';
                    push @rules, $rrr . "-P $rule{'chain'} $policy\n";
                    $tables{$rule{'table'}.'_'.(lc $rule{'chain'})} |= 1 ; };
                last; };
            mydie (" cannot set the policy for non-built in chains, exiting"); }; };

    if ( $option{'createchains'} ) {
        # check if the chain is already defined
        if ( ! exists $tables{$rule{'table'}.'_'.(lc $rule{'chain'})} ) {
            push @rules, $rrr . "-N $rule{'chain'}\n" ;
            $tables{$rule{'table'} . '_' . lc $rule{'chain'}} = 0 };

        # check for unknown jump target
        for ( $rule{'action'} ) {
            last unless $rule{action} and
              not is_netfilter_builtin_target($rule{action});
            if ( ! exists ($tables{$rule{'table'}.'_'.(lc $_)}) ) {
                push @rules, $rrr . "-N $_\n";
                $tables{$rule{'table'} . '_' . lc $_} = 0 }; }; }
    else {
        # tag em so were not flushing it empty...
        if ( ! exists $tables{$rule{'table'} . '_' . (lc $rule{'chain'})} ) {
            $tables{$rule{'table'} . '_' . lc $rule{'chain'}} = 0 };
        for ( $rule{'action'} ) {
            last unless $rule{action} and
              not is_netfilter_builtin_target($rule{action});
            if ( ! exists ($tables{$rule{'table'} . '_' . lc $_}) ) {
                $tables{$rule{'table'} . '_' . lc $_} = 0 }; }; }

    # flush neccesary chains before referencing them
    if ( $option{'flushchains'} && (! ($option{'flushall'} || $option{'clearall'}) ) ) {
        # check if the chain is already defined
        if ( ($tables{$rule{'table'} . '_' . (lc $rule{'chain'})} & 2) != 2 ) {
            push @rules, $rrr . "-F $rule{'chain'}\n" ;
            $tables{$rule{'table'} . '_' . (lc $rule{'chain'})} |= 2; };
        # check for unknown jump target
        for ( $rule{'action'} ) {
            last unless $rule{action} and
              not is_netfilter_builtin_target($rule{action});
            if (($tables{$rule{'table'} . '_' . (lc $rule{'chain'})}&  2) != 2 ) {
                push @rules, $rrr . "-F $rule{'chain'}\n";
                $tables{$rule{'table'} . '_' . (lc $rule{'chain'})} |= 2;
            };
        };
    };

    # exit if no action is present - in case of policy only
    if ( !defined $rule{'action'} ) {
        push @rules, $rr;
        return; };

    $rr .= "$option{'location'} ";

    if (defined $rule{'table'} ) {
        $rr .= "-t " . $rule{'table'} . " "; };

    $rr .= "-A ";

    $rr .= $rule{'chain'} . " ";
    if (defined $rule{'interface'} ) {
        $rr .= "-i " . $rule{'interface'} . " " ; };
    if (defined $rule{'outerface'} ) {
        $rr .= "-o " . $rule{'outerface'} . " " ; };

    if (defined $rule{'proto'} ) {
        $rr .= "-p " . $rule{'proto'} . " "; };

    # modules
    my %modules = ( ( exists $rule{modules}
                      ? %{$rule{modules}}
                      : () ),
                    ( $option{automod} && exists $rule{auto_modules}
                      ? %{$rule{auto_modules}}
                      : () )
                  );

    foreach my $module (keys %modules) {
        $rr .= '-m ' . $module . ' ';
    }

    # address and port
    if (defined $rule{'saddr'} ) {
        $rr .= "-s " . $rule{'saddr'} . " " ;}
    if ( defined $rule{'sport'} ) {
        $rr .= "--sport " . $rule{'sport'} . " ";}
    if (defined $rule{'daddr'} ) {
        $rr .= "-d " . $rule{'daddr'} . " " ;}
    if ( defined $rule{'dport'} ) {
        $rr .= "--dport " . $rule{'dport'} . " ";}

    if (defined $rule{'icmptype'} ) {
        $rr .= "--icmp-type " . $rule{'icmptype'} . " "; } ;
    if (defined $rule{'syn'} ) {
        if ( $rule{'syn'} eq 'set' ) {
            $rr .= '--syn '  ; }
        else {
            $rr .= '! --syn '; } ;
        } ;
    $rr .= "--mss $rule{mss} "
      if exists $rule{mss};

    if (defined $rule{'mark'} ) {
        $rr .= "--mark " . $rule{'mark'} . " "; } ;
    if (defined $rule{'fragment'} ) {
        if ( $rule{'fragment'} eq 'set' ) {
            $rr .= '-f '  ; }
        else {
            $rr .= '! -f '; } ;
        } ;

    # iptables extensions:
    shell_append(\$rr, '--tcp-flags', $rule{flagsmask}, $rule{flagsmatch})
      if exists $rule{tcpflags};

    if (defined $rule{'tcpoption'} ) {
        $rr .= "--tcp-option " . $rule{'tcpoption'} . " "; } ;

    if (defined $rule{'string'} ) {
        $rr .= "--string " . $rule{'string'} . " "; } ;

    # target
    $rr .= "-j $rule{action} "
      unless $rule{'action'} eq 'NOP';

    # check for '--to' and '--to-[ports|source|destination]'
    if (defined $rule{'to'}) {
        $rr .= "--to " . $rule{'to'} . " "; };
    if (defined $rule{'toports'}) {
        $rr .= "--to-ports " . $rule{'toports'} . " "; };
    if (exists $rule{tosrc}) {
        foreach (split /,/, $rule{tosrc}) {
            shell_append(\$rr, '--to-source', $_);
        }
    }
    if (defined $rule{'tosrc'}) {
        $rr .= "--to-source " . $rule{'tosrc'} . " "; };
    if (defined $rule{'todest'}) {
        $rr .= "--to-destination " . $rule{'todest'} . " "; };

    if (defined $rule{'ttlset'} ) {
        $rr .= "--ttl-set " . $rule{'ttlset'} . " "; } ;
    if (defined $rule{'ttlinc'} ) {
        $rr .= "--ttl-inc " . $rule{'ttlinc'} . " "; } ;
    if (defined $rule{'ttldec'} ) {
        $rr .= "--ttl-dec " . $rule{'ttldec'} . " "; } ;


    if (defined $rule{'settos'} ) {
        # some translations for ferm 1.1 compatibility
        $rule{settos} =~ s/^min-?cost$/0x02/;
        $rule{settos} =~ s/^(?:reliability|reliable)$/0x04/;
        $rule{settos} =~ s/^max-?throughput$/0x08/;
        $rule{settos} =~ s/^(?:lowdelay|interactive|min-delay)$/0x10/;
        $rule{settos} =~ s/^clear$/0x00/;

        $rr .= "--set-tos $rule{settos} ";
    }

    if (defined $rule{'loglevel'} ) {
        $rr .= "--log-level " . $rule{'loglevel'} . " "; };
    shell_append(\$rr, '--log-prefix', $rule{'logprefix'})
      if exists $rule{'logprefix'};
    if (defined $rule{'logsequence'} ) {
        $rr .= "--log-tcp-sequence "; };
    if (defined $rule{'logtcpoptions'} ) {
        $rr .= "--log-tcp-options "; };
    if (defined $rule{'logipoptions'} ) {
        $rr .= "--log-ip-options "; } ;

    if (defined $rule{'ulog-nlgroup'} ) {
        $rr .= "--ulog-nlgroup " . $rule{'ulog-nlgroup'} . " " } ;
    if (defined $rule{'ulog-prefix'} ) {
        $rr .= "--ulog-prefix " . $rule{'ulog-prefix'} . " " } ;
    if (defined $rule{'ulog-cprange'} ) {
        $rr .= "--ulog-cprange " . $rule{'ulog-cprange'} . " " } ;
    if (defined $rule{'ulog-qthreshold'} ) {
        $rr .= "--ulog-qthreshold " . $rule{'ulog-qthreshold'} . " " } ;

    if (defined $rule{'rejectwith'} ) {
        $rr .= "--reject-with " . $rule{'rejectwith'} . " " } ;

    if ( defined $rule{'clamp-mss-to-pmtu'} ) {
        $rr .= "--clamp-mss-to-pmtu "; } ;
    if ( defined $rule{'set-mss'} ) {
        $rr .= "--set-mss " . $rule{'set-mss'} . " " } ;

    # ipt_addrtype parameters
    $rr .= "--src-type " . $rule{srctype} . " "
      if exists $rule{srctype};
    $rr .= "--dst-type " . $rule{dsttype} . " "
      if exists $rule{dsttype};

    # ipt_ah parameters
    $rr .= "--ahspi $rule{ahspi} "
      if exists $rule{ahspi};

    # ipt_conntrack parameters
    shell_append(\$rr, '--ctstate', $rule{ctstate})
      if exists $rule{ctstate};

    foreach (qw(ctproto ctorigsrc ctorigdst),
             qw(ctreplsrc ctrepldst ctstatus ctexpire)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }

    # ipt_iplimit parameters
    $rr .= "--iplimit-above $rule{iplimitabove} "
      if exists $rule{iplimitabove};

    $rr .= "--iplimit-mask $rule{iplimitmask} "
      if exists $rule{iplimitmask};

    # ipt_length parameters
    $rr .= "--length $rule{length} "
      if exists $rule{length};

    # ipt_limit parameters
    $rr .= "--limit $rule{limit} "
      if exists $rule{limit};

    $rr .= "--limit-burst $rule{limitburst} "
      if exists $rule{limitburst};

    # ipt_mac parameters
    $rr .= "--mac-source $rule{macsource} "
      if exists $rule{macsource};

    # ipt_mark parameters
    $rr .= "--set-mark $rule{setmark} "
      if exists $rule{setmark};

    # ipt_nth parameters
    foreach (qw(every counter start packet)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }

    # ipt_owner parameters
    foreach (qw(uid gid pid sid cmd)) {
        $rr .= "--${_}-owner $rule{${_} . 'owner'} "
          if exists $rule{${_} . 'owner'};
    }

    # ipt_pkttype switches
    $rr .= "--pkt-type $rule{pkttype} "
      if exists $rule{pkttype};

    # ipt_psd switches
    $rr .= "--psd-weight-threshold $rule{psdweightthreshold} "
      if exists $rule{psdweightthreshold};
    $rr .= "--psd-delay-threshold $rule{psddelaythreshold} "
      if exists $rule{psddelaythreshold};
    $rr .= "--psd-lo-ports-weight $rule{psdloportsweight} "
      if exists $rule{psdloportsweight};
    $rr .= "--psd-hi-ports-weight $rule{psdhiportsweight} "
      if exists $rule{psdhiportsweight};

    # ipt_random parameters
    $rr .= "--average $rule{average} "
      if exists $rule{average};

    # ipt_recent parameters
    foreach (qw(name seconds hitcount)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }
    foreach (qw(set rcheck update remove rttl)) {
        $rr .= "--$_ "
          if exists $rule{$_};
    }

    # ipt_state parameters
    shell_append(\$rr, '--state', $rule{state})
      if exists $rule{state};

    # ipt_time parameters
    shell_append(\$rr, '--days', $rule{days})
      if exists $rule{days};

    foreach (qw(timestart timestop datestart datestop)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }

    # ipt_tos parameters
    if (exists $rule{tos}) {
        # some translations for ferm 1.1 compatibility
        $rule{tos} =~ s/^min-?cost$/0x02/;
        $rule{tos} =~ s/^(?:reliability|reliable)$/0x04/;
        $rule{tos} =~ s/^max-?throughput$/0x08/;
        $rule{tos} =~ s/^(?:lowdelay|interactive|min-delay)$/0x10/;
        $rule{tos} =~ s/^clear$/0x00/;

        $rr .= "--tos $rule{tos} ";
    }

    # ipt_ttl parameters
    foreach (qw(ttl-eq ttl-lt ttl-gt)) {
        my $key = $_;
        $key =~ s/-//;

        $rr .= "--$_ $rule{$key} "
          if exists $rule{$key};
    }

    # this line is done
    $rr .= "\n";
    push @rules, $rr;
};

sub ip_tables_names {
    my @tables;

    local *TABLES;
    open TABLES, '</proc/net/ip_tables_names'
      or return qw(filter nat mangle);

    while (<TABLES>) {
        push @tables, $1
          if /(\w+)/;
    }

    close TABLES;

    return @tables;
}

sub clearall {
    # flush and delete all chains...
    flushall();

    foreach my $table (ip_tables_names) {
        push @rules, "$option{'location'} \-X -t $table\n";
    }
}


sub flushall {
    # flush all chains...
    foreach my $table (ip_tables_names) {
        push @rules, "$option{'location'} \-F -t $table\n";
    }
    $tables{'filter_input'} |= 2;
    $tables{'filter_forward'} |= 2;
    $tables{'filter_output'} |= 2;
    $tables{'nat_prerouting'} |= 2;
    $tables{'nat_postrouting'} |= 2;
    $tables{'nat_output'} |= 2;
    $tables{'mangle_prerouting'} |= 2;
    $tables{'mangle_output'} |= 2;
}


sub printrule {
    my $rule = shift;

    # debug: print whatever is in memory
    if ($debug) {
        my $db;
        $db = "# Rule parsed   : ";
        while (my ($key, $value) = each %$rule) {
            $db .= $key . "=" . $value . " ";
        };
        push @rules, $db . "\n";
    };

    # prints all rules in a hash
    tables($rule);
}


sub mkrules {
    my $fw = shift;

    # compile the list hashes into rules
    my @fr;

    # pack the data in a handy format (list-of-hashes with one kw
    # per level, so we can recurse...
    my $db;
    if ($debug) {
        $db = "# Rule unparsed :  ";
    };

    for (my $i = 0; $i < @$fw; $i++) {
        while (my ($key, $value) = each %{$fw->[$i]}) {
            $db .= "${key}[$i]=$value "
              if $debug;

            push @fr, { $key => $value };
        }
    }

    if ($debug) {
        push @rules, "$db\n ";
    };

    sub dofr {
        my $rule = shift;
        my $current = shift;

        # loop over all keys in this level (only 1)
        while (my ($key, $value_string) = each %$current) {
            unless (ref $value_string) {
                # set this one and recurse
                $rule->{$key} = $value_string;

                if (@_) {
                    dofr($rule, @_);
                } else {
                    printrule($rule);
                }

                delete $rule->{$key};
            } elsif (ref $value_string eq 'ARRAY') {
                # recurse for every value
                foreach my $value (@$value_string) {
                    $value =~ s/^!/! /;
                    # set this one and recurse
                    $rule->{$key} = $value;

                    if (@_) {
                        dofr($rule, @_);
                    } else {
                        printrule($rule);
                    }
                }

                delete $rule->{$key};
            } elsif (ref $value_string eq 'HASH') {
                # merge hashes
                my $old = $rule->{$key};

                $rule->{$key} = { ( defined $old
                                    ? %$old
                                    : ()
                                  ),
                                  %$value_string
                                };

                # recurse
                if (@_) {
                    dofr($rule, @_);
                } else {
                    printrule($rule);
                }

                # restore old value
                if (defined $old) {
                    $rule->{$key} = $old;
                } else {
                    delete $rule->{$key};
                }
            } else {
                die ref $value_string;
            }
        }
    }

    dofr({}, @fr);
}

sub find_option {
    my ($fw, $key) = @_;

    my $item = (grep { exists $_->{$key} } reverse @$fw)[0];
    return unless defined $item;

    return $item->{$key};
}

sub enter {
    my $lev = shift;  # current recursion depth
    my @fw = @_; # fwset in list of hashes

    die unless @fw == $lev;

    # enter is the core of the firewall setup, it is a
    # simple parser program that recognizes keywords and
    # retreives parameters to set up the kernel routing
    # chains

    if ($debug) {
        push @rules, "# entered level $lev\n";
    };

    my $current = {};
    push @fw, $current;

    # read keywords 1 by 1 and dump into parser
    while (defined (my $keyword = next_token())) {
        $verbose && print ".";

        # check if the current rule should be negated
        my $negated = $keyword eq '!';
        if ($negated) {
            # negation. get the next word which contains the 'real'
            # rule
            $keyword = getvar();
            $verbose && print ".";

            error('unexpected end of file after negation')
              unless defined $keyword;

            error('double negation')
              if $keyword eq '!';
        }

        # the core: parse all data
        SWITCH: for ($keyword)
        {
            # choose a side
            if ($keyword =~ /^(?:source|src)$/) {
                $current->{side} = 'source';
                next;
            }

            if ($keyword =~ /^(?:destination|dest)$/) {
                $current->{side} = 'destination';
                next;
            }

            if ($keyword =~ /^(?:port|addr)$/) {
                error("source/destination not declared, exiting")
                  unless exists $current->{side};
                if ($current->{side} eq 'source') {
                    $keyword = 's' . $keyword;
                } elsif ($current->{side} eq 'destination') {
                    $keyword = 'd' . $keyword;
                }
            }

            # where to put the rule?
            if ($keyword eq 'table') {
                error('Table is already specified')
                  if exists $current->{table};
                $current->{table} = getvalues();
                next;
            }
            if ($keyword eq 'chain') {
                error('Chain is already specified')
                  if exists $current->{chain};
                $current->{chain} = getvalues();
                next;
            }

            # routing base parameters
            /^interface$|if$/ && do {
                $current->{'interface'}=getvalues();
                ; next; } ;
            /^outerface$|^out-interface$|^of$/ && do {
                $current->{'outerface'}=getvalues();
                ; next; } ;
            /^protocol$|^proto$/ && do {
                $current->{'proto'}=getvalues();
                ; next; } ;

            /^saddr$/ && do {
                $current->{'saddr'}=getvalues();
                ; next; };
            /^daddr$/ && do {
                $current->{'daddr'}=getvalues();
                ; next; };

            # extended parameters:
            /^module$|^mod$|^match$/ && do {
                foreach my $module(to_array getvalues) {
                    $current->{modules}{$module} = 1;
                }
                ; next; };

            # miscelleanous switches
            /^fragment$|^frag$/ && do {
                if ($negated) {
                    $current->{'fragment'}='unset';
                    undef $negated;
                } else {
                    $current->{'fragment'}='set';}
                ; next; } ;

            ###
            # actions
            #

            # jump action
            if (/^(?:goto|jump)$/) {
                error('There is only one action per rule')
                  if exists $current->{action};
                $current->{action} = getvar();
                next;
            };

            # policy keywords
            if ($keyword eq 'policy') {
                my $policy = uc getvar();
                error('invalid policy target, exiting')
                  unless $policy =~ /^(?:ACCEPT|DROP)$/;
                $current->{policy} = $policy;
                next;
            }

            # action keywords
            s/^MASQ$/MASQUERADE/i;

            if ($keyword =~ /^(?:ACCEPT|DROP|RETURN|QUEUE|NOP
                                |BALANCE|DNAT|MASQUERADE|MIRROR|REDIRECT|REJECT
                                |SNAT|TCPMSS|TTL|ULOG
                              )$/ix or
                $keyword =~ /^(?:CLASSIFY|CLUSTERIP|CONNMARK|DSCP|ECN
                                |LOG|MARK|NETMAP|ROUTE|TOS|TRACE
                              )$/) {
                error('There is only one action per rule')
                  if exists $current->{action};
                $current->{'action'} = uc $keyword;
                next;
            }

            ###
            # protocol specific options
            #

            my $proto = find_option(\@fw, 'proto');

            # icmp protocol switches
            if (defined $proto and
                $proto eq 'icmp' and
                $keyword =~ /^icmp-?type$/) {
                $current->{icmptype} = getvalues();
                next;
            }

            # tcp protocol switches
            if (defined $proto and
                $proto eq 'tcp') {
                if ($keyword =~ /^[sd]port$/) {
                    $current->{$keyword} = getvalues();
                    next;
                }
                if ($keyword =~ /^(?:tcp-?)flags$/) {
                    $current->{tcpflags} = 1;
                    $current->{flagsmask} = join(',', to_array getvalues());
                    $current->{flagsmatch} = join(',', to_array getvalues());
                    next;
                }
                if ($keyword eq 'syn') {
                    # match tcp packages with syn-byte set
                    if ($negated) {
                        $current->{syn} = 'unset';
                        undef $negated;
                    } else {
                        $current->{syn} = 'set';
                    }
                    next;
                }
                if ($keyword =~ /^tcp-?option$/) {
                    $current->{tcpoption} = getvalues();
                    next;
                }
                if ($keyword eq 'mss') {
                    $current->{mss} = getvalues();
                    next;
                }
            }

            # udp protocol switches
            if (defined $proto and
                $proto eq 'udp' and
                $keyword =~ /^[sd]port$/) {
                $current->{$keyword} = getvalues();
                next;
            }

            ###
            # module specific options
            #

            # ipt_addrtype switches
            /^(?:src|dst)-?type$/ && do {
                s/-//;
                $current->{$_} = getvalues();
                $current->{auto_modules}{addrtype} = 1;
                next;
            };

            # ipt_ah switches
            /^ah-?spi$/ && do {
                s/-//;
                $current->{$_} = getvalues();
                $current->{auto_modules}{ah} = 1;
                next;
            };

            # ipt_conntrack switches
            /^ctstate$/ && do {
                $current->{$keyword} = join(',', to_array getvalues());
                $current->{auto_modules}{conntrack} = 1;
                next;
            };

            /^(?:ctproto|ct(?:orig|repl)(?:src|dst)|ctstatus|ctexpire)$/ && do {
                $current->{$keyword} = getvalues();
                $current->{auto_modules}{conntrack} = 1;
                next;
            };

            /^ctexpire$/ && do {
                $current->{$keyword} = getvar();
                $current->{auto_modules}{conntrack} = 1;
                next;
            };

            # ipt_iplimit switches
            /^ip-?limit-?(?:above|mask)$/ && do {
                s/-//;
                $current->{$_} = getvar();
                $current->{auto_modules}{iplimit} = 1;
                next;
            };

            # ipt_length switches
            /^length$/ && do {
                $current->{'length'}=getvar();
                $current->{auto_modules}{length} = 1;
                ; next; };

            # ipt_limit switches
            /^limit$/ && do {
                $current->{'limit'}=getvar();
                $current->{auto_modules}{limit} = 1;
                ; next; };
            /^burst$|^limit-?burst$/ && do {
                $current->{'limitburst'}=getvar();
                $current->{auto_modules}{limit} = 1;
                ; next; };

            # ipt_mac switches
            /^mac$|^mac-source$|^macsource$/ && do {
                $current->{'macsource'}=getvalues();
                $current->{auto_modules}{mac} = 1;
                ; next; };

            # ipt_mark switches
            /^mark$/ && do {
                $current->{'mark'}=getvar();
                $current->{auto_modules}{mark} = 1;
                ; next; };

            # ipt_nth switches
            /^every$|^counter$|^start$|^packet$/ && do {
                $current->{$keyword}=getvar();
                $current->{auto_modules}{nth} = 1;
                ; next; };

            # ipt_owner switches
            /^(uid|gid|pid|sid|cmd)(?:-?owner)?$/ && do {
                $current->{$1 . 'owner'} = getvalues();
                $current->{auto_modules}{owner} = 1;
                next;
            };

            # ipt_pkttype switches
            /^pkt-?type$/ && do {
                s/-//;
                $current->{$_} = getvalues();
                $current->{auto_modules}{pkttype} = 1;
                next;
            };

            # ipt_psd switches
            /^(?:psd-?weight-?threshold|psd-?delay-?threshold|
                 psd-?lo-?ports-?weight|psd-?hi-?ports-?weight)$/x && do {
                s/-//;
                $current->{$_} = getvar();
                $current->{auto_modules}{psd} = 1;
                next;
            };

            # ipt_random switches
            /^average$/ && do {
                $current->{'average'}=getvar();
                $current->{auto_modules}{random} = 1;
                ; next; };

            # ipt_recent switches
            /^(?:name|seconds|hitcount)$/ && do {
                $current->{$keyword}=getvar();
                $current->{auto_modules}{recent} = 1;
                next;
            };
            /^(?:set|rcheck|update|remove|rttl)$/ && do {
                $current->{$keyword}=1;
                $current->{auto_modules}{recent} = 1;
                next;
            };

            # ipt_state switches
            /^state$/ && do {
                $current->{state} = join(',', to_array getvalues());
                $current->{auto_modules}{state} = 1;
                ; next; };

            # ipt_time switches
            /^days$/ && do {
                $current->{days} = join(',', to_array getvalues());
                $current->{auto_modules}{time} = 1;
                next;
            };

            /^(?:timestart|timestop|datestart|datestop)$/ && do {
                $current->{$keyword}=getvar();
                $current->{auto_modules}{time} = 1;
                ; next; };

            # ipt_tos switches
            /^tos$/ && do {
                $current->{'tos'}=getvar();
                $current->{auto_modules}{tos} = 1;
                ; next; };

            # ipt_ttl switches
            /^ttl-?(?:eq|lt|gt)$/ && do {
                s/-//;
                $current->{$_} = getvar();
                $current->{auto_modules}{ttl} = 1;
                next;
            };

            ###
            # target specific options
            #

            if (defined $current->{action}) {
                # DNAT target switches
                if ($current->{action} eq 'DNAT' and
                    $keyword =~ /^(?:to-destination|todest)$/) {
                    $current->{todest} = getvar();
                    next;
                }

                # LOG target switches
                if ($current->{action} eq 'LOG') {
                    if ($keyword =~ /^(?:log-level|loglev)$/) {
                        $current->{loglevel} = getvar();
                        next;
                    }
                    if ($keyword =~ /^log-?prefix$/) {
                        $current->{logprefix} = getvar();
                        next;
                    }
                    if ($keyword =~ /^(?:log-tcp-sequence|logseq)$/) {
                        $current->{logsequence} = 1;
                        next;
                    }
                    if ($keyword =~ /^(?:log-tcp-options|logtcpopt)$/) {
                        $current->{logtcpoptions} = 1;
                        next;
                    }
                    if ($keyword =~ /^(?:log-ip-options|logipopt)$/) {
                        $current->{logipoptions} = 1;
                        next;
                    }
                }

                # MARK/CONNMARK target switches
                if (($current->{action} eq 'MARK' or
                     $current->{action} eq 'CONNMARK') and
                    $keyword =~ /^set-?mark$/) {
                    $current->{setmark} = getvar();
                    next;
                }

                # MASQUERADE/REDIRECT target switches
                if (($current->{action} eq 'MASQUERADE' or
                     $current->{action} eq 'REDIRECT') and
                    $keyword =~ /^to-?ports$/) {
                    $current->{toports} = getvar();
                    next;
                }

                # NETMAP target switches
                if ($current->{action} eq 'NETMAP' and
                    $keyword eq 'to') {
                    $current->{to} = getvar();
                    next;
                }

                # REJECT target switches
                if ($current->{action} eq 'REJECT' and
                    $keyword =~ /^reject-?with$/) {
                    $current->{rejectwith} = getvar();
                    next;
                }

                # SNAT target switches
                if ($current->{action} eq 'SNAT' and
                    $keyword =~ /^(?:to-source|tosrc)$/) {
                    $current->{tosrc} = join(',', to_array getvalues());
                    next;
                }

                # TCPMSS target switches
                if ($current->{action} eq 'TCPMSS') {
                    if ($keyword eq 'set-mss') {
                        $current->{$keyword} = getvar();
                        next;
                    }

                    if ($keyword eq 'clamp-mss-to-pmtu') {
                        $current->{$keyword} = 'set';
                        next;
                    }
                }

                # TOS target switches
                if ($current->{action} eq 'TOS' and
                    $keyword =~ /^set-?tos$/) {
                    $keyword =~ s/-//;
                    $current->{$keyword} = getvar();
                    next;
                }

                # TTL target switches
                if ($current->{action} eq 'TTL' and
                    $keyword =~ /^ttl-?(?:set|dec|inc)$/) {
                    $keyword =~ s/-//;
                    $current->{$keyword} = getvar();
                    next;
                }

                # ULOG target switches
                if ($current->{action} eq 'ULOG' and
                    $keyword =~ /^ulog-(?:nlgroup|prefix|cprange|qthreshold)$/) {
                    $current->{$keyword} = getvar();
                    next;
                }
            }

            # effectuation operator
            /(\x3b)/ && do {
                # check for action (required)
                error("no action or policy defined, exiting")
                  unless grep {
                      exists $_->{action} or exists $_->{policy}
                  } @fw;
                # check for chain (required)
                error("no chain defined, exiting")
                  unless grep {
                      exists $_->{chain}
                  } @fw;

                # clear any policy-related stuff in this level
                if (grep { exists $_->{policy} } @fw) {
                    $tables{'filter_input'} &= 2;
                    $tables{'filter_forward'} &= 2;
                    $tables{'filter_output'} &= 2;
                    $tables{'nat_prerouting'} &= 2;
                    $tables{'nat_postrouting'} &= 2;
                    $tables{'nat_output'} &= 2;
                    $tables{'mangle_prerouting'} &= 2;
                    $tables{'mangle_output'} &= 2;
                }

                mkrules(\@fw);

                # and clean up variables set in this level
                %$current = ();

                ; next ; } ;

            # recursing operators
            /\x7b/ && do {
                enter($lev + 1, @fw);

                # after a block, the command is finished, clear this
                # level
                %$current = ();

                ; next SWITCH; };
            /\x7d/ && do {
                # consistency check: check if they hanven't
                # forgotten the ';' before the last statement
                error("Missing semicolon before closing section, exiting")
                  if keys %$current;

                # clear any policy-related stuff in this level
                if (grep { exists $_->{policy} } @fw) {
                    $tables{'filter_input'} &= 2;
                    $tables{'filter_forward'} &= 2;
                    $tables{'filter_output'} &= 2;
                    $tables{'nat_prerouting'} &= 2;
                    $tables{'nat_postrouting'} &= 2;
                    $tables{'nat_output'} &= 2;
                    $tables{'mangle_prerouting'} &= 2;
                    $tables{'mangle_output'} &= 2;
                }

                # and exit
                if ($debug) {
                    push @rules, "# leaving level $lev\n";
                };

                return;
            };

            # default
            error("Unrecognized keyword: $keyword, exiting");
        }

        # if the rule didn't reset the negated flag, it's not
        # supported
        error("Doesn't support negation: $keyword, exiting")
          if $negated;
    }
};

# end of ferm

__END__

=head1 NAME

ferm - a firewall rule parser for linux

=head1 SYNOPSIS

B<ferm> I<options> I<inputfiles>

=head1 OPTIONS

 -n, --noexec      Do not execute the rules, just simulate
 -l, --lines       Show all rules that were created
 -v, --verbose     Show some more information
 -d, --debug       Show debug information
 -V, --version     Show current version number
 --clearall        Flush and delete all chains before adding rules
 --flushall        Flush all chains before adding rules
 --createchains    Create all neccesary chains
 --flushchains     Flush all used chains
 --automod         Enable automatic module parameters for iptables
 -h, --help        Look at this text
 --use [kernel firewall program]
                   Obsolete option, only iptables is supported
 --location /path/to/iptables
                   Specify the location and name of the kernel program

=cut
