#!/usr/bin/perl

#
# ferm, a firewall setup program that makes firewall rules easy!
#
# Copyright (C) 2001-2003  Auke Kok
#
# Comments, questions, greetings and additions to this program
# may be sent to <auke.kok@planet.nl>
#

#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

use strict;
use IO::File;

use vars qw($VERSION $DATE);

$VERSION = '1.1+cvs';
$DATE = '19 oct 2004';

# global data vars
my @rules;     # will contain all rules
my %chains;    # chain box for ipchains
    $chains{'input'} = 0;
    $chains{'forward'} = 0;
    $chains{'output'} = 0;
my %tables;    # chain box for iptables
    $tables{'filter_input'} = 0;
    $tables{'filter_forward'} = 0;
    $tables{'filter_output'} = 0;
    $tables{'nat_prerouting'} = 0;
    $tables{'nat_postrouting'} = 0;
    $tables{'nat_output'} = 0;
    $tables{'mangle_prerouting'} = 0;
    $tables{'mangle_output'} = 0;
               # 0=made;1=policy set;2=flushed;3=all
my $side='';   # source/destination pointer
my %option;    # some configuration options
my %vars;      # holds variable data

use vars qw($script);

use subs qw(open_script);

# Get command line stuff
use vars qw($opt_noexec $opt_lines $opt_verbose $opt_debug $opt_location),
  qw($opt_clearall $opt_flushall $opt_createchains),
  qw($opt_flushchains $opt_help $opt_automod $opt_version $opt_use);

use Getopt::Long;

GetOptions(
        'noexec', 'lines', 'verbose', 'debug', 'location=s',
        'clearall', 'flushall', 'createchains',
        'flushchains', 'help', 'automod', 'version', 'use=s'
          );

if (defined $opt_help) {
    printversion();
    # a brief handout to the user
    print "\nUsage:\n";
    print "ferm \[options\] \<files\>\n\n";
    print "options are:\n";
    print "        \-\-noexec          Do not execute the rules, just simulate\n";
    print "        \-\-lines           Show all rules that were created\n";
    print "        \-\-verbose         Show some more information\n";
    print "        \-\-debug           Show debug information\n";
    print "        \-\-version         Show current version number\n";
    print "        \-\-clearall        Flush and delete all chains before adding rules\n";
    print "        \-\-flushall        Flush all chains before adding rules\n";
    print "        \-\-createchains    Create all neccesary chains\n";
    print "        \-\-flushchains     Flush all used chains\n";
    print "        \-\-automod         Enable automatic module parameters for iptables\n";
    print "        \-\-help            Look at this text\n";
    print "        \-\-use [kernel firewall program]\n";
    print "                          Either iptables, ipchains or ipfwadm\n";
    print "        \-\-location /path/to/iptables\n";
    print "                          Specify the location and name of the kernel program\n";
    print "\n";
    print "For more detailed information and syntax description of the\n";
    print "firewall files, read \"man $0\".\n";
    exit 0;
};

if (defined $opt_version) {
    printversion();
    exit 0;
};

use vars qw($verbose $debug);

$option{'noexec'} = (defined $opt_noexec);
$option{'lines'} = (defined $opt_lines);
$verbose = (defined $opt_verbose);
$debug = (defined $opt_debug);
$option{'clearall'} = (defined $opt_clearall);
$option{'flushall'} = (defined $opt_flushall);
$option{'flushchains'} = (defined $opt_flushchains);
$option{'createchains'} = (defined $opt_createchains);
$option{'automod'} = (defined $opt_automod);
$option{'ipchains'} = $option{'iptables'} = $option{'ipfwadm'} = 0;
if (defined $opt_use) {
    $option{$opt_use} = 1;
    $option{frontend} = $opt_use;
}
if (defined $opt_location) {
    $option{'location'} = $opt_location;
    if ( ! -X $option{'location'}) {
        mydie("Specified location is not executable or does not exist! Exiting");
    }
}

$verbose && printversion();

mydie("Specify only one ferm script")
  unless @ARGV == 1;

open_script($ARGV[0]);

# option checks
mydie ('Unknown or no kernel interface specified, try to set "option [iptables|ipchains|ipfwadm] or use the --use parameter')
  unless defined $option{frontend};

if (defined $option{location}) {
    mydie("Specified location is not executable or does not exist! Exiting")
      unless -X $option{'location'};
} else {
    # set a default location
    $option{location} = $option{frontend};
}

# clearing and flushing needs to be done first:
$option{'clearall'} && clearall();
$option{'flushall'} && flushall();


# parse all input recursively
$verbose && print "Parsing files\n";
enter(0);

# and execute all generated rules
$verbose && print "\nExecuting rules\n";
foreach my $rr (@rules) {
    $rr =~ s/ $//g;
    if ($option{'lines'} || $debug ) {
        print $rr; };
    if (!$option{'noexec'} ) {
        for ($rr) {
            !/^#/ && do {
                if ((!$option{'lines'}) && $verbose) {print "."};
                system ($rr);
            };
        };
    };
}

$verbose && print "Done, exiting\n";
exit 0;

# end of program execution!


# funcs

sub printversion {
    print "ferm $VERSION, $DATE\n";
    print "Copyright (C) 2001-2003 - Auke Kok, released under the GPLv2\n";
    print "See the included COPYING file for license details.\n";
}


sub mydie {
    print STDERR @_; print "\n";
    exit 1;
}


sub error {
    # returns a nice formatted error message, showing the
    # location of the error.
    my $tabs = 0;
    my @lines;
    my $l = 0;
    my @words = @{$script->{past_tokens}};

    for my $w ( 0 .. $#words ) {
        if ($words[$w] eq "\x29")
            { $l++ ; $lines[$l] = "    " x ($tabs-- -1) ;};
        if ($words[$w] eq "\x28")
            { $l++ ; $lines[$l] = "    " x $tabs++ ;};
        if ($words[$w] eq "\x7d")
            { $l++ ; $lines[$l] = "    " x ($tabs-- -1) ;};
        if ($words[$w] eq "\x7b")
            { $l++ ; $lines[$l] = "    " x $tabs++ ;};
        if ( $l > $#lines ) { $lines[$l] = "" };
        $lines[$l] .= $words[$w] . " ";
        if ($words[$w] eq "\x28")
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x29") && ($words[$w+1] ne "\x7b"))
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if ($words[$w] eq "\x7b")
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x7d") && ($words[$w+1] ne "\x7d"))
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x3b") && ($words[$w+1] ne "\x7d"))
            { $l++ ; $lines[$l] = "    " x $tabs ;}
        if ($words[$w-1] eq "option")
            { $l++ ; $lines[$l] = "    " x $tabs ;}
    }
    my $start = $#lines - 4;
    if ($start < 0) { $start = 0 } ;
    print STDERR "Error in $script->{filename} line $script->{line}:\n";
    for $l ( $start .. $#lines)
        { print STDERR $lines[$l]; if ($l != $#lines ) {print "\n"} ; };
    print STDERR "<--\n";
    mydie(@_);
}

sub tokenize_string {
    # split the an input string into words
    my ($string) = @_;

    my @ret;

    foreach my $word ($string =~ m/(\x22[^\x22]+\x22|\x27[^\x27]+\x27|\x60[^\x60]+\x60|!|[0-9a-zA-Z\x23-\x26\x2a-\x3a\x3c-\x7a\x7c\x7e\x7f]+|\x28|\x29|\x7b|\x7d|\x3b)/g) {
        # explanation of all sections:
        # \x22[^\x22]+\x22 == "*"
        # \x27[^\x27]+\x27 == '*'
        # \x60[^\x60]+\x60 == `*`
        # [0-9a-zA-Z\x23-\x26\x2a-\x3a\x3c-\x7a\x7c\x7e\x7f]+
        #        == anything which is not one of these:
        # \x28 == (
        # \x29 == )
        # \x7b == }
        # \x7d == {
        # \x3b == ;
        push @ret, $word;
    }

    return @ret;
}

sub getvar2 {
    # see if $array->[0] is contains variables, and try to substitute
    # them with their values
    my $array = shift;
    die unless ref $array eq 'ARRAY';

    my $w = shift @$array;
    # Substitute all variables in this strings if present
    while ( $w =~ s/\x25([0-9a-zA-Z\x2d\x5f]+)/$vars{$1}/ ) {
        if ($debug) {
            my $db = "# substituting variables: \%$1 ";
            push @rules, "$db -\> $vars{$1}\n";
        }
    }
    return $w;
}


sub getvalues2 {
    # retrieves a list of parameters given, syntax:
    # [keyword]|"("{keyword}")"
    # starts to read at $c++
    my $array = shift;

    my @wordlist;
    my $firstword = getvar2($array);

    return $firstword
      if $firstword =~ /^[\x22\x27\x60]/;
    if ($firstword eq '(') {
        # read a list until ")"
        my $nextword;
        do {
            $nextword = getvar2($array);
            if ( $nextword ne ')' ) {
                if ( $nextword eq '!' ) {
                    $nextword .= getvar2($array);
                };
                push @wordlist, $nextword;
            };
        } until ( $nextword eq ')' );
        return (join(',', @wordlist));
    } elsif ( $firstword eq '!' ) {
        return $firstword . getvar2($array);
    } else {
        return $firstword;
    };
}


sub setvar {
    my $vname = shift;
    my $vval = shift;

    for ($vval) {
        /^\x60/ && do {
            my $db;
            if ($debug) {
                $db = "# Executing backticks: $vval "; };
            # change all ' to \'
            $vval =~ s/'/\\'/g;
            # change `.....` to qx'.....' to prevent perl interpretation
            $vval =~ s/^\x60(.*)\x60$/qx'$1'/;
            $vval = eval($vval);
            # change newlines to comma's, omitting the last newline char
            $vval =~ s'\n$'';
            $vval =~ s'\n','g;
            if ($debug) {
                push @rules, "$db -\> $vval\n"; };
        };
        /^\x22/ && do {
            $vval =~ s/\x22//g;
        }
    }

    $vars{$vname} = $vval;
}

sub prepare_tokens {
    return
      unless defined $script;

    my $tokens = $script->{tokens};
    die unless ref $tokens eq 'ARRAY';

    while (@$tokens == 0) {
        my $line = $script->{handle}->getline;
        unless (defined $line) {
            # end of file, switch to the next in the chain and recurse
            # to read tokens from this file
            $script = $script->{parent};
            return prepare_tokens();
        }

        $script->{line} ++;

        # chop comments:
        $line =~ s/#.*$//g;

        my @line = tokenize_string($line);

        # look at the first word, then decide what to do. some special
        # keywords are handled here, everything else gets added to @tokens
        if ($line[0] eq 'option') {
            # option: edit the %option hash
            shift @line;
            my $name = shift @line;
            my $value = shift @line;

            unless (defined $value) {
                $value = 1;
            } elsif ($value eq 'off') {
                $value = undef;
            }

            $option{$name} = $value;

            $option{frontend} = $name
              if $value and $name =~ /^(?:ipfwadm|ipchains|iptables)$/;
        } elsif ($line[0] eq 'set') {
            # set: set a variable
            shift @line;
            my $name = shift @line;
            my $value = getvalues2(\@line);
            setvar($name, $value);
        } elsif ($line[0] eq 'include') {
            # include: include another file
            shift @line;

            my $filename = shift @line;

            # check if the file exists
            mydie("No such file in $script->{filename} line $script->{line}: $filename")
              unless -f $filename;

            # prevent opening the same file twice at a time
            for (my $s = $script; defined $s; $s = $s->{parent}) {
                mydie("Circular reference in $script->{filename} line $script->{line}: $filename")
                  if $s->{filename} eq $filename;
            }

            # open it, put it on stack
            open_script($filename);
            last;
        } else {
            # the next parser stage eats this
            push @$tokens, @line;
        }
    }

    return 1;
}

sub open_script {
    my $filename = shift;

    my $handle = new IO::File("<$filename");
    mydie("Failed to open $filename: $!")
      unless defined $handle;

    $script = { filename => $filename,
                handle => $handle,
                line => 0,
                past_tokens => [],
                tokens => [],
                parent => $script,
              };

    prepare_tokens();

    return $script;
}

sub next_token {
    # get a token
    prepare_tokens();

    return
      unless defined $script;

    my $tokens = $script->{tokens};
    die unless ref $tokens eq 'ARRAY';

    return
      unless @$tokens;

    my $token = shift @$tokens;

    # update $script->{past_tokens}
    my $past_tokens = $script->{past_tokens};
    die unless ref $past_tokens eq 'ARRAY';

    if (@$past_tokens and
        ($past_tokens->[@$past_tokens - 1] eq '}' or
         $past_tokens->[@$past_tokens - 1] eq ';')) {
        # now this is tricky: $script->{past_tokens} is used in error
        # messages. in the following lines, we filter out everything
        # which has become irrelevant for error messages,
        # i.e. previous (completed) commands

        my $t = pop @$past_tokens;

        # track the current level - a '}' means one level up (we are
        # going backwards)
        my $level = $t eq '}' ? 1 : 0;

        while (@$past_tokens and $level >= 0) {
            $t = pop @$past_tokens;

            if ($level == 0 and ($t eq '}' or $t eq ';')) {
                # don't delete another command
                push @$past_tokens, $t;
                last;
            } elsif ($t eq '}') {
                # one level up
                $level++;
            } elsif ($t eq '{') {
                # one level down. stop here if we're already at level
                # zero
                if ($level == 0) {
                    push @$past_tokens, $t;
                    last;
                }

                $level--;
            }
        }
    }

    push @$past_tokens, $token;

    # return
    return $token;
}

sub getvar {
    # see if the next_token() contains variables, and try to
    # substitute them with their values

    my $w = next_token();

    # a parameter is expected, EOF is fatal
    error('unexpected end of file')
      unless defined $w;

    # a parameter cannot be one of the "special" tokens
    error("unexpected '$w'")
      if $w =~ /^[;{}]/;

    # Substitute all variables in this strings if present
    while ( $w =~ s/\x25([0-9a-zA-Z\x2d\x5f]+)/$vars{$1}/ ) {
        if ($debug) {
            my $db = "# substituting variables: \%$1 ";
            push @rules, "$db -\> $vars{$1}\n";
        }
    }
    return $w;
}


sub getvalues {
    # retreives a list of parameters given, syntax:
    # [keyword]|"("{keyword}")"
    # starts to read at $c++

    my $token = getvar();

    if ($token eq '(') {
        # read a list until ")"
        my @wordlist;

        while (($token = getvar()) ne ')') {
            $token .= getvar()
              if $token eq '!';
            push @wordlist, $token;
        }

        return (join(',', @wordlist));
    } elsif ($token eq '!') {
        return $token . getvar();
    } else {
        return $token;
    }
}

# here are the three currently known fw-set interfaces to the kernel

sub chains {
    my $rule = shift;
    my %rule = %$rule;

    # ipchains
    my $rr = "";

    # should we set a policy?
    if ( exists $rule{'policy'} ) {
        for ( $rule{'chain'} ) {
            /^input$|^forward$|^output$/ && do {
                if ( ! ($chains{$rule{'chain'}} & 1) ) {
                    my $policy = $rule{policy};
                    $policy = 'DENY'
                      if $policy eq 'DROP';
                    push @rules, "$option{'location'} -P $rule{'chain'} $policy\n";
                    $chains{$rule{'chain'}} |= 1 ; };
                last; };
            mydie (" cannot set the policy for non-built in chains, exiting"); }; };

    if ( $option{'createchains'} ) {
        # check if the chain is already defined
        if ( ! exists $chains{$rule{'chain'}} ) {
            push @rules, "$option{'location'} -N $rule{'chain'}\n" ;
            $chains{$rule{'chain'}} = 0 };

        # check for unknown jump target
        for ( $rule{'action'} ) {
            /^accept$|^drop$|^reject$|^return$|^masq$|^redirect$|^nop$|^$/ && last;
            if ( ! exists ($chains{$_}) ) {
                push @rules, "$option{'location'} -N $_\n";
                $chains{$_} = 0 }; }; }
    else {
        # tag em so were not flushing it empty...
        if ( ! exists $chains{$rule{'chain'}} ) {
            $chains{$rule{'chain'}} = 0 ;
        };
        for ( $rule{'action'} ) {
            /^accept$|^drop$|^reject$|^return$|^masq$|^redirect$|^$/ && last;
            if ( ! exists ($chains{$_}) ) {
                $chains{$_} = 0;
            };
        };
    };

    # flush neccesary chains before referencing them
    if ( $option{'flushchains'} && (! ($option{'flushall'} || $option{'clearall'}) )) {
        # check if the chain is not already flushed
        if ( ($chains{$rule{'chain'}} & 2) != 2 ) {
            push @rules, "$option{'location'} -F $rule{'chain'}\n" ;
            $chains{$rule{'chain'}} |= 2; };
        # check for jump target to be flushed
        for ( $rule{'action'} ) {
            /^accept$|^drop$|^reject$|^return$|^masq$|^redirect$|^nop$|^$/ && last;
            if ( ($chains{$rule{'action'}} & 2) != 2 ) {
                push @rules, "$option{'location'} -F $rule{'action'}\n";
                $chains{$rule{'action'}} |= 2 ;};
        };
    };

    # exit if no action is present - in case of policy only
    if ( !defined $rule{'action'} ) {
        push @rules, $rr;
        return; };

    $rr .= "ipchains -A ";
    $rr .= $rule{'chain'} . " ";
    if (defined $rule{'interface'} ) {
        $rr .= "-i " . $rule{'interface'} . " " ; };
    if (defined $rule{'proto'} ) {
        $rr .= "-p " . $rule{'proto'} . " "; };

    # address and port
    if (defined $rule{'saddr'} ) {
        $rr .= "-s " . $rule{'saddr'} . " " ;
        if ( defined $rule{'sport'} ) {
            $rr .= $rule{'sport'} . " ";} }
    else {
        if ( defined $rule{'sport'} ) {
            $rr .= "--sport " . $rule{'sport'} . " ";} }
    if (defined $rule{'daddr'} ) {
        $rr .= "-d " . $rule{'daddr'} . " " ;
        if ( defined $rule{'dport'} ) {
            $rr .= $rule{'dport'} . " ";} }
    else {
        if ( defined $rule{'dport'} ) {
            $rr .= "--dport " . $rule{'dport'} . " ";} }

    if (defined $rule{'reverse'} ) {
        $rr .= "-b " };

    if (defined $rule{'icmptype'} ) {
        $rr .= "--icmp-type " . $rule{'icmptype'} . " "; } ;
    if (defined $rule{'syn'} ) {
        if ( $rule{'syn'} eq 'set' ) {
            $rr .= '-y '  ; }
        else {
            $rr .= '! -y '; } ;
        } ;
    if (defined $rule{'settos'} ) {
        $rr .= "-t e1 ";
        for ( $rule{'settos'} ) {
            /mincost|min-cost|2/ && do { $rr .= "02 "};
            /reliability|reliable|4/ && do { $rr .= "04 "};
            /max-throughput|maxthroughput|8/ && do { $rr .= "08 "};
            /lowdelay|interactive|min-delay|10/ && do { $rr .= "10 "};
            /clear|^0$|^00$|^0x00$/ && do { $rr .= "00 "};
            }
        ; } ;
    if (defined $rule{'setmark'} ) {
        $rr .= "-m " . $rule{'setmark'} . " "; } ;
    if (defined $rule{'fragment'} ) {
        if ( $rule{'fragment'} eq 'set' ) {
            $rr .= '-f '  ; }
        else {
            $rr .= '! -f '; } ;
        } ;
    unless ($rule{'action'} eq 'nop') {
        $rr .= "-j "; } ;
    for ( $rule{'action'} ) {
        /^accept$/ && do { $rr .= "ACCEPT " ; last; };
        /^drop$/ && do { $rr .= "DENY " ; last; };
        /^reject$/ && do { $rr .= "REJECT " ; last; };
        /^masq$/ && do { $rr .= "MASQ " ; last; };
        /^redirect$/ && do { $rr .= "REDIRECT " . $rule{'to'} ; last; };
        /^return$/ && do { $rr .= "RETURN " ; last; };
        /^nop$/ && last;
        $rr .= $rule{'action'} . " "; } ;
    if (defined $rule{'log'} ) {
        $rr .= "-l"; } ;
    $rr .= "\n";
    push @rules, $rr;
}


sub tables {
    my $rule = shift;
    my %rule = %$rule;

    # iptables, for 2.3/2.4 kernels
    my $rr = "";
    my $rrr = "";

    # pre-setup rrr for creation of chains
    if (!defined $rule{'table'} ) {
         $rule{'table'} = 'filter';}
    $rrr .= "$option{'location'} -t " . $rule{'table'} . " ";

    # in iptables, built-in chains are UPPERCASE
    for( $rule{'chain'} ) {
        /^input$|^forward$|^output$|^prerouting$|^postrouting$/ && do {
            $rule{'chain'} = uc $rule{'chain'} ; } };

    # should we set a policy?
    if ( exists $rule{'policy'} ) {
        for ( $rule{'chain'} ) {
            /^INPUT$|^FORWARD$|^OUTPUT$|^PREROUTING$|^POSTROUTING$/ && do {
                if ( ! ($tables{$rule{'table'} . '_' . lc $rule{'chain'}} & 1) ) {
                    my $policy = $rule{policy};
                    $policy = 'DROP'
                      if $policy eq 'REJECT';
                    push @rules, $rrr . "-P $rule{'chain'} $policy\n";
                    $tables{$rule{'table'}.'_'.(lc $rule{'chain'})} |= 1 ; };
                last; };
            mydie (" cannot set the policy for non-built in chains, exiting"); }; };

    if ( $option{'createchains'} ) {
        # check if the chain is already defined
        if ( ! exists $tables{$rule{'table'}.'_'.(lc $rule{'chain'})} ) {
            push @rules, $rrr . "-N $rule{'chain'}\n" ;
            $tables{$rule{'table'} . '_' . lc $rule{'chain'}} = 0 };

        # check for unknown jump target
        for ( $rule{'action'} ) {
            /^accept$|^balance$|^dnat$|^drop$|^ftos$|^log$|^mark$|^masq$|^mirror$|^netlink$|^nop$|^queue$|^redirect$|^reject$|^return$|^snat$|^tcpmss$|^tos$|^ttl$|^ulog$|^$/ && last;
            if ( ! exists ($tables{$rule{'table'}.'_'.(lc $_)}) ) {
                push @rules, $rrr . "-N $_\n";
                $tables{$rule{'table'} . '_' . lc $_} = 0 }; }; }
    else {
        # tag em so were not flushing it empty...
        if ( ! exists $tables{$rule{'table'} . '_' . (lc $rule{'chain'})} ) {
            $tables{$rule{'table'} . '_' . lc $rule{'chain'}} = 0 };
        for ( $rule{'action'} ) {
            /^accept$|^balance$|^dnat$|^drop$|^ftos$|^log$|^mark$|^masq$|^mirror$|^netlink$|^nop$|^queue$|^redirect$|^reject$|^return$|^snat$|^tcpmss$|^tos$|^ttl$|^ulog$|^$/ && last;
            if ( ! exists ($tables{$rule{'table'} . '_' . lc $_}) ) {
                $tables{$rule{'table'} . '_' . lc $_} = 0 }; }; }

    # flush neccesary chains before referencing them
    if ( $option{'flushchains'} && (! ($option{'flushall'} || $option{'clearall'}) ) ) {
        # check if the chain is already defined
        if ( ($tables{$rule{'table'} . '_' . (lc $rule{'chain'})} & 2) != 2 ) {
            push @rules, $rrr . "-F $rule{'chain'}\n" ;
            $tables{$rule{'table'} . '_' . (lc $rule{'chain'})} |= 2; };
        # check for unknown jump target
        for ( $rule{'action'} ) {
            /^accept$|^balance$|^dnat$|^drop$|^ftos$|^log$|^mark$|^masq$|^mirror$|^netlink$|^nop$|^queue$|^redirect$|^reject$|^return$|^snat$|^tcpmss$|^tos$|^ttl$|^ulog$|^$/ && last;
            if (($tables{$rule{'table'} . '_' . (lc $rule{'chain'})}&  2) != 2 ) {
                push @rules, $rrr . "-F $rule{'chain'}\n";
                $tables{$rule{'table'} . '_' . (lc $rule{'chain'})} |= 2;
            };
        };
    };

    # exit if no action is present - in case of policy only
    if ( !defined $rule{'action'} ) {
        push @rules, $rr;
        return; };

    $rr .= "$option{'location'} ";

    if (defined $rule{'table'} ) {
        $rr .= "-t " . $rule{'table'} . " "; };

    $rr .= "-A ";

    $rr .= $rule{'chain'} . " ";
    if (defined $rule{'interface'} ) {
        $rr .= "-i " . $rule{'interface'} . " " ; };
    if (defined $rule{'outerface'} ) {
        $rr .= "-o " . $rule{'outerface'} . " " ; };

    if (defined $rule{'proto'} ) {
        $rr .= "-p " . $rule{'proto'} . " "; };

    # modules
    my %modules = ( ( exists $rule{modules}
                      ? %{$rule{modules}}
                      : () ),
                    ( $option{automod} && exists $rule{auto_modules}
                      ? %{$rule{auto_modules}}
                      : () )
                  );

    foreach my $module (keys %modules) {
        $rr .= '-m ' . $module . ' ';
    }

    # address and port
    if (defined $rule{'saddr'} ) {
        $rr .= "-s " . $rule{'saddr'} . " " ;}
    if ( defined $rule{'sport'} ) {
        $rr .= "--sport " . $rule{'sport'} . " ";}
    if (defined $rule{'daddr'} ) {
        $rr .= "-d " . $rule{'daddr'} . " " ;}
    if ( defined $rule{'dport'} ) {
        $rr .= "--dport " . $rule{'dport'} . " ";}

    if (defined $rule{'icmptype'} ) {
        $rr .= "--icmp-type " . $rule{'icmptype'} . " "; } ;
    if (defined $rule{'syn'} ) {
        if ( $rule{'syn'} eq 'set' ) {
            $rr .= '--syn '  ; }
        else {
            $rr .= '! --syn '; } ;
        } ;

    if (defined $rule{'mark'} ) {
        $rr .= "--mark " . $rule{'mark'} . " "; } ;
    if (defined $rule{'fragment'} ) {
        if ( $rule{'fragment'} eq 'set' ) {
            $rr .= '-f '  ; }
        else {
            $rr .= '! -f '; } ;
        } ;

    # iptables extensions:
    if (defined $rule{'tcpflags'} ) {
        $rr .= "--tcp-flags " . join(',',split(/:/,$rule{'flagsmask'})) . " "
                                . join(',',split(/:/,$rule{'flagsmatch'})) . " ";};
    if (defined $rule{'tcpoption'} ) {
        $rr .= "--tcp-option " . $rule{'tcpoption'} . " "; } ;

    if (defined $rule{'string'} ) {
        $rr .= "--string " . $rule{'string'} . " "; } ;

    unless ($rule{'action'} eq 'nop') {
        $rr .= "-j "; } ;

    if (defined $rule{'log'} ) {
        push @rules, $rr . "LOG\n"; }

    # special options come after "-j TARGET"

    for ( $rule{'action'} ) {
        /^masq$/ && do { $rr .= "MASQUERADE " ;  last; };
        /^nop$/ && last;
        /^accept$|^balance$|^dnat$|^drop$|^ftos$|^log$|^mark$|^mirror$|^netlink$|^queue$|^redirect$|^reject$|^return$|^snat$|^tcpmss$|^tos$|^ttl$|^ulog$|^$/ && do {
             $rr .= (uc $rule{'action'}) . " " ; last; };
        $rr .= $rule{'action'};
    };

    # check for '--to' and '--to-[ports|source|destination]'
    if (defined $rule{'to'}) {
        $rr .= "--to " . $rule{'to'} . " "; };
    if (defined $rule{'toports'}) {
        $rr .= "--to-ports " . $rule{'toports'} . " "; };
    if (defined $rule{'tosrc'}) {
        $rr .= "--to-source " . $rule{'tosrc'} . " "; };
    if (defined $rule{'todest'}) {
        $rr .= "--to-destination " . $rule{'todest'} . " "; };

    if (defined $rule{'ttlset'} ) {
        $rr .= "--ttl-set " . $rule{'ttlset'} . " "; } ;
    if (defined $rule{'ttlinc'} ) {
        $rr .= "--ttl-inc " . $rule{'ttlinc'} . " "; } ;
    if (defined $rule{'ttldec'} ) {
        $rr .= "--ttl-dec " . $rule{'ttldec'} . " "; } ;


    if (defined $rule{'settos'} ) {
        $rr .= "--set-tos ";
        for ( $rule{'settos'} ) {
            /mincost|min-cost|2/ && do { $rr .= "0x02 "};
            /reliability|reliable|4/ && do { $rr .= "0x04 "};
            /max-throughput|maxthroughput|8/ && do { $rr .= "0x08 "};
            /lowdelay|interactive|min-delay|10/ && do { $rr .= "0x10 "};
            /clear|^0$|^00$|^0x00$/ && do { $rr .= "0x00 "};
            }
        ; } ;
    if (defined $rule{'setftos'} ) {
        $rr .= "--set-ftos " . $rule{'setftos'} . " "; };

    if (defined $rule{'loglevel'} ) {
        $rr .= "--log-level " . $rule{'loglevel'} . " "; };
    if (defined $rule{'logprefix'} ) {
        $rr .= "--log-prefix " . $rule{'logprefix'} . " "; };
    if (defined $rule{'logsequence'} ) {
        $rr .= "--log-tcp-sequence "; };
    if (defined $rule{'logtcpoptions'} ) {
        $rr .= "--log-tcp-options "; };
    if (defined $rule{'logipoptions'} ) {
        $rr .= "--log-ip-options "; } ;

    if (defined $rule{'ulog-nlgroup'} ) {
        $rr .= "--ulog-nlgroup " . $rule{'ulog-nlgroup'} . " " } ;
    if (defined $rule{'ulog-prefix'} ) {
        $rr .= "--ulog-prefix " . $rule{'ulog-prefix'} . " " } ;
    if (defined $rule{'ulog-cprange'} ) {
        $rr .= "--ulog-cprange " . $rule{'ulog-cprange'} . " " } ;
    if (defined $rule{'ulog-qthreshold'} ) {
        $rr .= "--ulog-qthreshold " . $rule{'ulog-qthreshold'} . " " } ;

    if (defined $rule{'rejectwith'} ) {
        $rr .= "--reject-with " . $rule{'rejectwith'} . " " } ;

    if ( defined $rule{'clamp-mss-to-pmtu'} ) {
        $rr .= "--clamp-mss-to-pmtu "; } ;
    if ( defined $rule{'set-mss'} ) {
        $rr .= "--set-mss " . $rule{'set-mss'} . " " } ;

    if ( defined $rule{'nldrop'} ) {
        $rr .= "--nldrop "; } ;
    if ( defined $rule{'nlmark'} ) {
        $rr .= "--nlmark " . $rule{'nlmark'} . " " } ;
    if ( defined $rule{'nlsize'} ) {
        $rr .= "--nlsize " . $rule{'nlsize'} . " " } ;

    # ipt_addrtype parameters
    $rr .= "--src-type " . $rule{srctype} . " "
      if exists $rule{srctype};
    $rr .= "--dst-type " . $rule{dsttype} . " "
      if exists $rule{dsttype};

    # ipt_ah parameters
    $rr .= "--ahspi $rule{ahspi} "
      if exists $rule{ahspi};

    # ipt_conntrack parameters
    $rr .= '--ctstate ' . join(',', split(/:/, $rule{ctstate})) . ' '
      if exists $rule{ctstate};

    foreach (qw(ctproto ctorigsrc ctorigdst),
             qw(ctreplsrc ctrepldst ctstatus ctexpire)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }

    # ipt_iplimit parameters
    $rr .= "--iplimit-above $rule{iplimitabove} "
      if exists $rule{iplimitabove};

    $rr .= "--iplimit-mask $rule{iplimitmask} "
      if exists $rule{iplimitmask};

    # ipt_length parameters
    $rr .= "--length $rule{length} "
      if exists $rule{length};

    # ipt_limit parameters
    $rr .= "--limit $rule{limit} "
      if exists $rule{limit};

    $rr .= "--limit-burst $rule{limitburst} "
      if exists $rule{limitburst};

    # ipt_mac parameters
    $rr .= "--mac-source $rule{macsource} "
      if exists $rule{macsource};

    # ipt_mark parameters
    $rr .= "--set-mark $rule{setmark} "
      if exists $rule{setmark};

    # ipt_nth parameters
    foreach (qw(every counter start packet)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }

    # ipt_owner parameters
    foreach (qw(uid gid pid sid cmd)) {
        $rr .= "--${_}-owner $rule{${_} . 'owner'} "
          if exists $rule{${_} . 'owner'};
    }

    # ipt_pkttype switches
    $rr .= "--pkt-type $rule{pkttype} "
      if exists $rule{pkttype};

    # ipt_psd switches
    $rr .= "--psd-weight-threshold $rule{psdweightthreshold} "
      if exists $rule{psdweightthreshold};
    $rr .= "--psd-delay-threshold $rule{psddelaythreshold} "
      if exists $rule{psddelaythreshold};
    $rr .= "--psd-lo-ports-weight $rule{psdloportsweight} "
      if exists $rule{psdloportsweight};
    $rr .= "--psd-hi-ports-weight $rule{psdhiportsweight} "
      if exists $rule{psdhiportsweight};

    # ipt_random parameters
    $rr .= "--average $rule{average} "
      if exists $rule{average};

    # ipt_recent parameters
    foreach (qw(name seconds hitcount)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }
    foreach (qw(set rcheck update remove rttl)) {
        $rr .= "--$_ "
          if exists $rule{$_};
    }

    # ipt_state parameters
    $rr .= "--state " . join(',', split(/:/, $rule{state})) . " "
      if exists $rule{state};

    # ipt_time parameters
    $rr .= "--days " . join(',', split(/:/, $rule{days})) . " "
      if exists $rule{days};

    foreach (qw(timestart timestop datestart datestop)) {
        $rr .= "--$_ $rule{$_} "
          if exists $rule{$_};
    }

    # ipt_tos parameters
    if (exists $rule{tos}) {
        # some translations for ferm 1.1 compatibility
        $rule{tos} =~ s/^min-?cost$/0x02/;
        $rule{tos} =~ s/^(?:reliability|reliable)$/0x04/;
        $rule{tos} =~ s/^max-?throughput$/0x08/;
        $rule{tos} =~ s/^(?:lowdelay|interactive|min-delay)$/0x10/;
        $rule{tos} =~ s/^clear$/0x00/;

        $rr .= "--tos $rule{tos} ";
    }

    # ipt_ttl parameters
    foreach (qw(ttl-eq ttl-lt ttl-gt)) {
        my $key = $_;
        $key =~ s/-//;

        $rr .= "--$_ $rule{$key} "
          if exists $rule{$key};
    }

    # this line is done
    $rr .= "\n";
    push @rules, $rr;
};


sub fwadm {
    my $rule = shift;
    my %rule = %$rule;

    # obsolete ipfwadm
    my $rr;

    if ($rule{'chain'} eq 'input') { $rr = "\-I "; }
    elsif ($rule{'chain'} eq 'forward') { $rr = "\-F "; }
    elsif ($rule{'chain'} eq 'output') {$rr = "\-O "; }
    else { mydie("Cannot create new chains if using ipfwadm!");};

    if ($rule{'policy'} eq 'ACCEPT') { push @rules, "ipfwadm $rr\-p accept\n";}
    elsif ($rule{'policy'} eq 'DROP') { push @rules, "ipfwadm $rr\-p deny\n";}
    elsif ($rule{'policy'} eq 'REJECT') { push @rules, "ipfwadm $rr\-p reject\n";}
    elsif (exists $rule{'policy'}) { mydie("Ipfwadm allows only accept, deny and reject policies!");};

    # exit if no action is present - in case of policy only
    if ( !defined $rule{'action'} ) {
        return; };

    $rr = "$option{'location'} " . $rr;

    if ($rule{'action'} eq 'accept') { $rr .= "\-a accept "; }
    elsif ($rule{'action'} eq 'drop') { $rr .= "\-a deny "; }
    elsif ($rule{'action'} eq 'reject') {$rr .= "\-a reject "; }
    elsif ($rule{'action'} eq 'masq') {$rr .= "\-a accept \-m"; }
    else { mydie("Ipfwadm allows only accept, masq, deny and reject targets!");};

    if ((defined $rule{'interface'}) && ($rule{'chain'} eq 'output')) {
        $rr .= "\-W " . $rule{'interface'} . " " }
    elsif (defined $rule{'interface'}) {
        $rr .= "\-V " . $rule{'interface'} . " " };

    if (defined $rule{'proto'} ) {
        $rr .= "\-P " . $rule{'proto'} . " " };

    if (defined $rule{'saddr'} || exists $rule{'sport'} ) {
        $rr .= "\-S ";
        if (defined $rule{'saddr'}) {
            $rr .= $rule{'saddr'} . " "; };
        if (defined $rule{'sport'}) {
            $rr .= $rule{'sport'} . " "; }; };

    if (defined $rule{'daddr'} || defined $rule{'dport'} ) {
        $rr .= "\-D ";
        if (defined $rule{'daddr'}) {
            $rr .= $rule{'daddr'} . " "; };
        if (defined $rule{'dport'}) {
            $rr .= $rule{'dport'} . " "; }; };

    if (defined $rule{'settos'} ) {
        $rr .= "\-t e1 ";
        for ( $rule{'settos'} ) {
            /mincost|min-cost|2/ && do { $rr .= "02 "};
            /reliability|reliable|4/ && do { $rr .= "04 "};
            /max-throughput|maxthroughput|8/ && do { $rr .= "08 "};
            /lowdelay|interactive|min-delay|10/ && do { $rr .= "10 "};
            /clear|^0$|^00$|^0x00$/ && do { $rr .= "00 "};
            }
        ; } ;

    if (defined $rule{'syn'}) {
        $rr .= "-y "; } ;

    push @rules, $rr . "\n";
}

sub ip_tables_names {
    my @tables;

    local *TABLES;
    open TABLES, '</proc/net/ip_tables_names'
      or return qw(filter nat mangle);

    while (<TABLES>) {
        push @tables, $1
          if /(\w+)/;
    }

    close TABLES;

    return @tables;
}

sub clearall {
    # flush and delete all chains...
    if ($option{'ipchains'}) {
        flushall();
        push @rules, "$option{'location'} \-X\n" }
    elsif ($option{'iptables'} ) {
        flushall();

        foreach my $table (ip_tables_names) {
            push @rules, "$option{'location'} \-X -t $table\n";
        }
    } elsif ($option{'ipfwadm'} ) {
        flushall();
        # nothing to do here
        };
}


sub flushall {
    # flush all chains...
    if($option{'ipchains'}) {
        push @rules, "$option{'location'} \-F\n" ;
        $chains{'input'} |= 2;
        $chains{'forward'} |= 2;
        $chains{'output'} |= 2; }
    elsif ($option{'iptables'} ) {
        foreach my $table (ip_tables_names) {
            push @rules, "$option{'location'} \-F -t $table\n";
        }
        $tables{'filter_input'} |= 2;
        $tables{'filter_forward'} |= 2;
        $tables{'filter_output'} |= 2;
        $tables{'nat_prerouting'} |= 2;
        $tables{'nat_postrouting'} |= 2;
        $tables{'nat_output'} |= 2;
        $tables{'mangle_prerouting'} |= 2;
        $tables{'mangle_output'} |= 2; }
    elsif ($option{'ipfwadm'} ) {
        push @rules, "$option{'location'} \-I \-f\n";
        push @rules, "$option{'location'} \-F \-f\n";
        push @rules, "$option{'location'} \-O \-f\n"; };
}


sub printrule {
    my $rule = shift;

    # debug: print whatever is in memory
    if ($debug) {
        my $db;
        $db = "# Rule parsed   : ";
        while (my ($key, $value) = each %$rule) {
            $db .= $key . "=" . $value . " ";
        };
        push @rules, $db . "\n";
    };

    # prints all rules in a hash
    if ( $option{'ipchains'} ) { chains ($rule) ; }
    elsif ( $option{'iptables'} ) { tables ($rule) ; }
    elsif ( $option{'ipfwadm'} ) { fwadm ($rule) ; }
    else {
        mydie ('Unknown or no kernel interface specified, try to set "option [iptables|ipchains|ipfwadm] or use the --use parameter'); } ;
}


sub mkrules {
    my $fw = shift;

    # compile the list hashes into rules
    my @fr;

    # pack the data in a handy format (list-of-hashes with one kw
    # per level, so we can recurse...
    my $db;
    if ($debug) {
        $db = "# Rule unparsed :  ";
    };

    for (my $i = 0; $i < @$fw; $i++) {
        while (my ($key, $value) = each %{$fw->[$i]}) {
            $db .= "${key}[$i]=$value "
              if $debug;

            push @fr, { $key => $value };
        }
    }

    if ($debug) {
        push @rules, "$db\n ";
    };

    sub dofr {
        my $rule = shift;
        my $current = shift;

        # loop over all keys in this level (only 1)
        while (my ($key, $value_string) = each %$current) {
            # preparse value stuff: is unsplit value negated???
            my $negated = $value_string =~ /^\x21/;

            unless (ref $value_string) {
                # recurse for every value
                foreach my $value (split ",", $value_string) {
                    # if so, make sure the '!' is put before every value in it
                    if ( $negated ) {
                        for ($value) {
                            !/^\x21/ && do { $value = "\x21" . $value; }
                        }
                    }
                    $value =~ s/^!/! /;
                    # set this one and recurse
                    $rule->{$key} = $value;

                    if (@_) {
                        dofr($rule, @_);
                    } else {
                        printrule($rule);
                    }
                }

                delete $rule->{$key};
            } elsif (ref $value_string eq 'HASH') {
                # merge hashes
                my $old = $rule->{$key};

                $rule->{$key} = { ( defined $old
                                    ? %$old
                                    : ()
                                  ),
                                  %$value_string
                                };

                # recurse
                if (@_) {
                    dofr($rule, @_);
                } else {
                    printrule($rule);
                }

                # restore old value
                if (defined $old) {
                    $rule->{$key} = $old;
                } else {
                    delete $rule->{$key};
                }
            } else {
                die ref $value_string;
            }
        }
    }

    dofr({}, @fr);
}


sub enter {
    my $lev = shift;  # current recursion depth
    my @fw = @_; # fwset in list of hashes

    die unless @fw == $lev;

    # enter is the core of the firewall setup, it is a
    # simple parser program that recognizes keywords and
    # retreives parameters to set up the kernel routing
    # chains

    if ($debug) {
        push @rules, "# entered level $lev\n";
    };

    my $current = {};
    push @fw, $current;

    # read keywords 1 by 1 and dump into parser
    while (defined (my $keyword = next_token())) {
        $verbose && print ".";

        # check if the current rule should be negated
        my $negated = $keyword eq '!';
        if ($negated) {
            # negation. get the next word which contains the 'real'
            # rule
            $keyword = getvar();
            $verbose && print ".";

            error('unexpected end of file after negation')
              unless defined $keyword;

            error('double negation')
              if $keyword eq '!';
        }

        # the core: parse all data
        SWITCH: for ($keyword)
        {
            # routing base parameters
            /^chain$/ && do {
                $current->{'chain'} = getvalues();
                ; next; } ;
            /^interface$|if$/ && do {
                $current->{'interface'}=getvalues();
                ; next; } ;
            /^outerface$|^out-interface$|^of$/ && do {
                $current->{'outerface'}=getvalues();
                ; next; } ;
            /^protocol$|^proto$/ && do {
                $current->{'proto'}=getvalues();
                ; next; } ;
            /^sport$/ && do {
                $current->{'sport'}=getvalues();
                ; next; } ;
            /^dport$/ && do {
                $current->{'dport'}=getvalues();
                ; next; };
            /^port$/ && do {
                if ($side eq 'source' ) {
                    $current->{'sport'}=getvalues() }
                elsif ($side eq 'destination' ) {
                    $current->{'dport'}=getvalues() }
                else {
                    error("source/destination not declared, exiting");
                    }
                ; next; } ;
            /^icmptype$|^icmp-type$/ && do {
                $current->{'icmptype'}=getvalues();
                ; next; } ;
            /^saddr$/ && do {
                $current->{'saddr'}=getvalues();
                ; next; };
            /^daddr$/ && do {
                $current->{'daddr'}=getvalues();
                ; next; };
            /^addr$/ && do {
                if ($side eq 'source' ) {
                    $current->{'saddr'}=getvalues() }
                elsif ($side eq 'destination' ) {
                    $current->{'daddr'}=getvalues() }
                else {
                    error("source/destination not declared, exiting") };
                ; next; } ;

            # extended parameters:
            /^settos$/ && do {
                $current->{'settos'}=getvar();
                ; next; };
            /^set-?ftos$/ && do {
                $current->{'setftos'}=getvar();
                ; next; };
            /^(?:tcp-?)flags$/ && do {
                $current->{'tcpflags'}='1';
                $current->{'flagsmask'}=join(':',split(/\x2c/,getvalues()));
                $current->{'flagsmatch'}=join(':',split(/\x2c/,getvalues()));
                ; next; };
            /^tcp-?option$/ && do {
                $current->{'tcpoption'}=getvalues();
                ; next; };
            /^log-level$|^loglev$/ && do {
                $current->{'loglevel'}=getvar();
                ; next; };
            /^log-?prefix$/ && do {
                $current->{'logprefix'}=getvar();
                ; next; };
            /^log-tcp-sequence$|^logseq$/ && do {
                $current->{'logsequence'}='1';
                ; next; };
            /^log-tcp-options$|^logtcpopt$/ && do {
                $current->{'logtcpoptions'}='1';
                ; next; };
            /^log-ip-options$|^logipopt$/ && do {
                $current->{'logipoptions'}='1';
                ; next; };
            /^module$|^mod$|^match$/ && do {
                foreach my $module (split /\x2c|:/, getvalues()) {
                    $current->{modules}{$module} = 1;
                }
                ; next; };
            /^table$/ && do {
                $current->{'table'}=getvalues();
                ; next; };
            /^string$/ && do {
                $current->{'string'}=getvalues();
                # XXX: what's this?
                ; next; };
            /^nldrop$/ && do {
                $current->{'nldrop'}=1;
                ; next; };
            /^nlmark$|^nlsize$/ && do {
                $current->{$keyword}=getvar();
                ; next; };

            # miscelleanous switches
            /^reverse$|^bidirectional$|^swap$/ && do {
                $current->{'reverse'}='1';
                ; next; };
            /^syn$/ && do {
                # match tcp packages with syn-byte set
                if ($negated) {
                    $current->{'syn'}='unset';
                    undef $negated;
                } else {
                    $current->{'syn'}='set';}
                ; next; } ;
            /^fragment$|^frag$/ && do {
                if ($negated) {
                    $current->{'fragment'}='unset';
                    undef $negated;
                } else {
                    $current->{'fragment'}='set';}
                ; next; } ;
            /^source$|^src$/ && do {
                $side='source';
                ; next; } ;
            /^destination$|^dest$/&& do {
                $side='destination';
                ; next; } ;
            /^to$/ && do {
                $current->{'to'}=getvar();
                ; next; };

            # jump action
            /^goto$|^jump$/ && do {
                $current->{'action'}=getvar();
                ; next; };

            # policy keywords
            if ($keyword eq 'policy') {
                my $policy = uc getvar();
                $policy = 'DROP'
                  if $policy eq 'DENY';
                error('invalid policy target, exiting')
                  unless $policy =~ /^(?:ACCEPT|DROP|REJECT)$/;
                $current->{policy} = $policy;
                next;
            }

            # action keywords
            /^log$/i && do {
                if ($option{frontend} eq 'iptables'
                    and (not exists $current->{action} or
                         $keyword eq 'LOG')) {
                    # set "log" action

                    # for backwards compatibility with ferm 1.1, an
                    # existing action is only overwritten if "LOG" is
                    # written in all uppercase
                    $current->{action} = lc $keyword;
                } else {
                    # turn the logging switch on
                    $current->{log} = 'set';
                }
                next;
            };

            s/^deny$/drop/i;
            s/^proxy$/redirect/i;
            s/^masquerade$/masq/i;

            ( /^(?:dnat|snat|redirect|drop|masq|accept|balance|ftos|mirror|
                   netlink|nop|queue|reject|return|tcpmss|ttl|ulog)$/ix or
              /^(?:TOS|MARK|CONNMARK)$/ ) && do {
                if (exists $current->{action}) {
                    if ($current->{action} eq 'log') {
                        # if the action is already set to "log",
                        # change that to a "log" flag for backwards
                        # compatibility
                        $current->{log} = 'set';
                    } else {
                        error("two actions not allowed, exiting");
                    }
                }

                $current->{'action'} = lc $keyword;
                next;
            };

            # ipt_addrtype switches
            /^(?:src|dst)-?type$/ && do {
                s/-//;
                $current->{$_} = getvalues();
                $current->{modules}{addrtype} = 1;
                next;
            };

            # ipt_ah switches
            /^ah-?spi$/ && do {
                s/-//;
                $current->{$_} = getvalues();
                $current->{modules}{ah} = 1;
                next;
            };

            # ipt_conntrack switches
            /^ctstate$/ && do {
                $current->{$keyword} = getvalues();
                $current->{$keyword} =~ s/,/:/g;
                $current->{auto_modules}{conntrack} = 1;
                next;
            };

            /^(?:ctproto|ct(?:orig|repl)(?:src|dst)|ctstatus|ctexpire)$/ && do {
                $current->{$keyword} = getvalues();
                $current->{auto_modules}{conntrack} = 1;
                next;
            };

            /^ctexpire$/ && do {
                $current->{$keyword} = getvar();
                $current->{auto_modules}{conntrack} = 1;
                next;
            };

            # ipt_iplimit switches
            /^ip-?limit-?(?:above|mask)$/ && do {
                s/-//;
                $current->{$_} = getvar();
                $current->{auto_modules}{iplimit} = 1;
                next;
            };

            # ipt_length switches
            /^length$/ && do {
                $current->{'length'}=getvar();
                $current->{auto_modules}{length} = 1;
                ; next; };

            # ipt_limit switches
            /^limit$/ && do {
                $current->{'limit'}=getvar();
                $current->{auto_modules}{limit} = 1;
                ; next; };
            /^burst$|^limit-?burst$/ && do {
                $current->{'limitburst'}=getvar();
                $current->{auto_modules}{limit} = 1;
                ; next; };

            # ipt_mac switches
            /^mac$|^mac-source$|^macsource$/ && do {
                $current->{'macsource'}=getvalues();
                $current->{auto_modules}{mac} = 1;
                ; next; };

            # ipt_mark switches
            /^mark$/ && do {
                $current->{'mark'}=getvar();
                $current->{auto_modules}{mark} = 1;
                ; next; };

            # ipt_nth switches
            /^every$|^counter$|^start$|^packet$/ && do {
                $current->{$keyword}=getvar();
                $current->{auto_modules}{nth} = 1;
                ; next; };

            # ipt_owner switches
            /^(uid|gid|pid|sid|cmd)(?:-?owner)?$/ && do {
                $current->{$1 . 'owner'} = getvalues();
                $current->{auto_modules}{owner} = 1;
                next;
            };

            # ipt_pkttype switches
            /^pkt-?type$/ && do {
                s/-//;
                $current->{$_} = getvalues();
                $current->{auto_modules}{pkttype} = 1;
                next;
            };

            # ipt_psd switches
            /^(?:psd-?weight-?threshold|psd-?delay-?threshold|
                 psd-?lo-?ports-?weight|psd-?hi-?ports-?weight)$/x && do {
                s/-//;
                $current->{$_} = getvar();
                $current->{auto_modules}{psd} = 1;
                next;
            };

            # ipt_random switches
            /^average$/ && do {
                $current->{'average'}=getvar();
                $current->{auto_modules}{random} = 1;
                ; next; };

            # ipt_recent switches
            /^(?:name|seconds|hitcount)$/ && do {
                $current->{$keyword}=getvar();
                $current->{auto_modules}{recent} = 1;
                next;
            };
            /^(?:set|rcheck|update|remove|rttl)$/ && do {
                $current->{$keyword}=1;
                $current->{auto_modules}{recent} = 1;
                next;
            };

            # ipt_state switches
            /^state$/ && do {
                $current->{'state'}=join(':',split(/\x2c/,getvalues()));
                $current->{auto_modules}{state} = 1;
                ; next; };

            # ipt_time switches
            /^days$/ && do {
                $current->{days} = join(':', split(/,/, getvalues()));
                $current->{auto_modules}{time} = 1;
                next;
            };

            /^(?:timestart|timestop|datestart|datestop)$/ && do {
                $current->{$keyword}=getvar();
                $current->{auto_modules}{time} = 1;
                ; next; };

            # ipt_tos switches
            /^tos$/ && do {
                $current->{'tos'}=getvar();
                $current->{auto_modules}{tos} = 1;
                ; next; };

            # ipt_ttl switches
            /^ttl-?(?:eq|lt|gt)$/ && do {
                s/-//;
                $current->{$_} = getvar();
                $current->{auto_modules}{ttl} = 1;
                next;
            };

            # target switches
            if (defined $current->{action}) {
                # DNAT target switches
                if ($current->{action} eq 'dnat' and
                    $keyword =~ /^(?:to-destination|todest)$/) {
                    $current->{todest} = getvar();
                    next;
                }

                # MARK/CONNMARK target switches
                if (($current->{action} eq 'mark' or
                     $current->{action} eq 'connmark') and
                    $keyword =~ /^set-?mark$/) {
                    $current->{setmark} = getvar();
                    next;
                }

                # MASQUERADE/REDIRECT target switches
                if (($current->{action} eq 'masq' or
                     $current->{action} eq 'redirect') and
                    $keyword =~ /^to-?ports$/) {
                    $current->{toports} = getvar();
                    next;
                }

                # REJECT target switches
                if ($current->{action} eq 'reject' and
                    $keyword =~ /^reject-?with$/) {
                    $current->{rejectwith} = getvar();
                    next;
                }

                # SNAT target switches
                if ($current->{action} eq 'snat' and
                    $keyword =~ /^(?:to-source|tosrc)$/) {
                    $current->{tosrc} = getvar();
                    next;
                }

                # TCPMSS target switches
                if ($current->{action} eq 'tcpmss') {
                    if ($keyword eq 'set-mss') {
                        $current->{$keyword} = getvar();
                        next;
                    }

                    if ($keyword eq 'clamp-mss-to-pmtu') {
                        $current->{$keyword} = 'set';
                        next;
                    }
                }

                # TTL target switches
                if ($current->{action} eq 'ttl' and
                    $keyword =~ /^ttl-?(?:set|dec|inc)$/) {
                    $keyword =~ s/-//;
                    $current->{$keyword} = getvar();
                    next;
                }

                # ULOG target switches
                if ($current->{action} eq 'ulog' and
                    $keyword =~ /^ulog-(?:nlgroup|prefix|cprange|qthreshold)$/) {
                    $current->{$keyword} = getvar();
                    next;
                }
            }

            # effectuation operator
            /(\x3b)/ && do {
                # check for action (required)
                error("no action or policy defined, exiting")
                  unless grep {
                      exists $_->{action} or exists $_->{policy}
                  } @fw;
                # check for chain (required)
                error("no chain defined, exiting")
                  unless grep {
                      exists $_->{chain}
                  } @fw;

                # clear any policy-related stuff in this level
                if (grep { exists $_->{policy} } @fw) {
                    $chains{'input'} &= 2;
                    $chains{'forward'} &= 2;
                    $chains{'output'} &= 2;
                    $tables{'filter_input'} &= 2;
                    $tables{'filter_forward'} &= 2;
                    $tables{'filter_output'} &= 2;
                    $tables{'nat_prerouting'} &= 2;
                    $tables{'nat_postrouting'} &= 2;
                    $tables{'nat_output'} &= 2;
                    $tables{'mangle_prerouting'} &= 2;
                    $tables{'mangle_output'} &= 2;
                }

                mkrules(\@fw);

                # and clean up variables set in this level
                %$current = ();

                ; next ; } ;

            # recursing operators
            /\x7b/ && do {
                enter($lev + 1, @fw);

                # after a block, the command is finished, clear this
                # level
                %$current = ();

                ; next SWITCH; };
            /\x7d/ && do {
                # consistency check: check if they hanven't
                # forgotten the ';' before the last statement
                error("Missing semicolon before closing section, exiting")
                  if keys %$current;

                # clear any policy-related stuff in this level
                if (grep { exists $_->{policy} } @fw) {
                    $chains{'input'} &= 2;
                    $chains{'forward'} &= 2;
                    $chains{'output'} &= 2;
                    $tables{'filter_input'} &= 2;
                    $tables{'filter_forward'} &= 2;
                    $tables{'filter_output'} &= 2;
                    $tables{'nat_prerouting'} &= 2;
                    $tables{'nat_postrouting'} &= 2;
                    $tables{'nat_output'} &= 2;
                    $tables{'mangle_prerouting'} &= 2;
                    $tables{'mangle_output'} &= 2;
                }

                # and exit
                if ($debug) {
                    push @rules, "# leaving level $lev\n";
                };

                return;
            };

            # default
            error("Unrecognized keyword: $keyword, exiting");
        }

        # if the rule didn't reset the negated flag, it's not
        # supported
        error("Doesn't support negation: $keyword, exiting")
          if $negated;
    }
};

# end of ferm

