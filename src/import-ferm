#!/usr/bin/perl

#
# ferm, a firewall setup program that makes firewall rules easy!
#
# Copyright (C) 2001-2008 Auke Kok, Max Kellermann
#
# Comments, questions, greetings and additions to this program
# may be sent to <ferm@foo-projects.org>
#

# This tool allows you to import an existing firewall configuration
# into ferm.

#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# $Id$

use strict;

use Data::Dumper;

use vars qw($indent $table $chain @rules $domain $next_domain);

sub parse_table {
    map {
        /(.+)=(.+)/ ? ( $1 => $2 ) : ( $_ => $_ )
    } split(/\s+/s, shift);
}

my %p0 = parse_table(<<EOT);
f=fragment fragment
syn
clamp-mss-to-pmtu
ecn-tcp-cwr ecn-tcp-ece
physdev-is-in physdev-is-out physdev-is-bridged
set rcheck update remove rttl rsource rdest
save-mark restore-mark
log-tcp-sequence log-tcp-options log-ip-options log-uid
continue tee
strict next
fragres fragfirst fragmore fraglast
nodst random
ecn-tcp-remove
ahres
soft
rt-0-res rt-0-not-strict
ashort
save restore
new
ssrr lsrr no-srr rr ts ra any-opt
utc localtz
EOT

my %p1 = parse_table(<<EOT);
p=protocol
i=interface o=outerface
in-interface=interface out-interface=outerface
s=saddr d=daddr
source=saddr destination=daddr
dport sport
reject-with icmp-type icmpv6-type
to-ports to
tos mark
tcp-option mss set-mss
ttl-set
ulog-nlgroup ulog-prefix ulog-cprange ulog-qthreshold
src-type dst-type
ahspi ahlen
ctstate ctproto ctorigsrc ctorigdst ctreplsrc ctrepldst ctstatus ctexpire
dscp dscp-class
dstlimit
ecn-ip-ect
espspi
helper
iplimit-above iplimit-mask
src-range dst-range
length
limit limit-burst
mac-source
every counter start packet
uid-owner gid-owner pid-owner sid-owner cmd-owner
physdev-in physdev-out
pkt-type
psd-weight-threshold psd-delay-threshold
psd-lo-ports-weight psd-hi-ports-weight
average
realm
name seconds hitcount
timestart timestop days datestart datestop
tos
ttl-eq ttl-gt ttl-lt
set-class
set-mark set-xmark and-mark or-mark xor-mark mask
log-level log-prefix
oif iif gw
set-tos
ttl-set ttl-dec ttl-inc
comment
dir pol reqid spi proto mode tunnel-src tunnel-dst
dst-len
fragid fraglen
dccp-option
queue-num
set-dscp set-dscp-class
quota
condition
lower-limit upper-limit
hbh-len hbh-opts
hl-eq hl-lt hl-gt
rt-type rt-segsleft rt-len
hl-set hl-dec hl-inc
aaddr aname
hashlimit hashlimit-burst hashlimit-mode hashlimit-name
hashlimit-htable-size hashlimit-htable-max
hashlimit-htable-expire hashlimit-htable-gcinterval
connlimit-above connlimit-mask
connbytes connbytes-dir connbytes-mode
selctx
mh-type
probability
nflog-group nflog-prefix nflog-range nflog-threshold
hashmode clustermac total-nodes local-node hash-init
algo from string hex-string
and-tos or-tos xor-tos
EOT

my %p1c = parse_table(<<EOT);
state
source-ports destination-ports ports
dst-opts
dccp-types
header
rt-0-addrs
monthday weekdays
EOT

my %p1multi = parse_table(<<EOT);
to-source
to-destination
u32
EOT

my %p2c = parse_table(<<EOT);
tcp-flags
chunk-types
add-set del-set
EOT

my @pre_negated = qw(fragment connbytes connlimit-above
rr ts ra any-opt
set rcheck update remove seconds hitcount
syn mss
physdev-is-in physdev-is-out physdev-is-bridged
);

my @mix_negated = qw(
iplimit-above
src-range dst-range
realm
tos
);

my @negated = qw(
protocol saddr daddr interface outerface sport dport
ahspi ahlen condition connrate
ctorigsrc ctorigdst ctreplsrc ctrepldst
espspi src-cc dst-cc
icmp-type icmpv6-type
mac-source source-ports destination-ports ports
genre realm chunk-types
tcp-flags tcp-option
dst-len hbh-len
fragid fraglen
dccp-types dccp-option
condition
hl-eq
header
length
physdev-in physdev-out
rt-type rt-segsleft rt-len
mh-type
);

sub is_netfilter_core_target {
    my $target = shift;
    die unless defined $target and length $target;

    return $target =~ /(?:ACCEPT|DROP|RETURN|QUEUE|NOP)$/;
}

sub is_netfilter_module_target {
    my $target = shift;
    die unless defined $target and length $target;

    return $target =~ /(?:BALANCE|CLASSIFY|CLUSTERIP|CONNMARK
                         |DNAT|DSCP|ECN|LOG|MARK|MASQUERADE
                         |MIRROR|NETMAP|REDIRECT|REJECT|ROUTE
                         |SNAT|TCPMSS|TOS|TRACE|TTL|ULOG
                         |TARPIT
                       )/x;
}

sub ferm_escape {
    local $_ = shift;
    return $_ unless /[^-\w.:]/s;
    return "\'$_\'";
}

sub format_array {
    my $a = shift;
    return ferm_escape($a) unless ref $a;
    return ferm_escape($a->[0]) if @$a == 1;
    return '(' . join(' ', map { ferm_escape($_) } @$a) . ')';
}

sub write_line {
    # write a line of tokens, with indent handling

    # don't add space before semicolon
    my $comma = $_[-1] eq ';' ? pop : '';
    # begins with closing curly braces -> decrease indent
    $indent -= 4 if $_[0] =~ /^}/;
    # do print line
    print ' ' x $indent;
    print join(' ', @_);
    print "$comma\n";
    # ends with opening curly braces -> increase indent
    $indent += 4 if $_[-1] =~ /{$/;
}

sub module_match_count {
    my ($module, $rules) = @_;
    my $count = 0;
    foreach (@$rules) {
        last unless $_->{mod}{$module};
        $count++;
    }
    return $count;
}

sub prefix_matches {
    my ($a, $b) = @_;
    return @{$b->{match}} > 0 &&
      (Dumper($a->{match}[0]) eq Dumper($b->{match}[0]));
}

sub prefix_match_count {
    my ($prefix, $rules) = @_;
    my $count = 0;
    foreach (@$rules) {
        last unless prefix_matches($prefix, $_);
        $count++;
    }
    return $count;
}

sub is_merging_array_member {
    my $value = shift;
    return defined $value &&
      ((!ref($value)) or
       ref $value eq 'ARRAY');
}

sub array_matches($$) {
    my ($rule1, $rule2) = @_;
    return unless is_merging_array_member($rule1->{match}[0][1]);
    return unless is_merging_array_member($rule2->{match}[0][1]);
    return unless @{$rule2->{match}} > 0;
    return unless $rule1->{match}[0][0] eq $rule2->{match}[0][0];
    my %r1 = %$rule1;
    my %r2 = %$rule2;
    $r1{match} = [ @{$r1{match}} ];
    $r2{match} = [ @{$r2{match}} ];
    shift @{$r1{match}};
    shift @{$r2{match}};
    return Dumper(\%r1) eq Dumper(\%r2);
}

sub array_match_count($\@) {
    my ($first, $rules) = @_;
    return 0 unless @{$first->{match}} > 0;
    my $count = 0;
    foreach (@$rules) {
        last unless array_matches($first, $_);
        $count++;
    }
    return $count;
}

sub optimize {
    my @result;

    # try to combine rules with arrays:
    # saddr 1.2.3.4 proto tcp ACCEPT;
    # saddr 5.6.7.8 proto tcp ACCEPT;
    # ->
    # saddr (1.2.3.4 5.6.7.8) proto tcp ACCEPT;
    while (@_ > 0) {
        my $rule = shift;
        my $match_count = array_match_count($rule, @_);

        if ($match_count > 0) {
            my $option = $rule->{match}[0][0];
            my @matching = ( $rule, splice(@_, 0, $match_count) );
            my @params = map {
                (ref $_ and ref $_ eq 'ARRAY') ? @$_ : $_
            } map {
                $_->{match}[0][1]
            } @matching;

            $rule->{match}[0][1] = \@params;
        }

        push @result, $rule;
    }

    @_ = @result;
    undef @result;

    # try to find a common prefix and put rules in a block:
    # saddr 1.2.3.4 proto tcp dport ssh ACCEPT;
    # saddr 5.6.7.8 proto tcp dport ssh DROP;
    # ->
    # proto tcp dport ssh {
    #     saddr 1.2.3.4 ACCEPT;
    #     saddr 5.6.7.8 DROP;
    # }
    while (@_ > 0) {
        my $rule = shift;
        if (@{$rule->{match}} > 0) {
            my $match_count = prefix_match_count($rule, \@_);

            if ($match_count > 0) {
                my $match = $rule->{match}[0];
                my @matching = ( $rule, splice(@_, 0, $match_count) );
                map { shift @{$_->{match}} } @matching;

                push @result, { match => [ $match ],
                                block => [ optimize(@matching) ],
                              };
            } else {
                push @result, $rule;
            }
        } else {
            push @result, $rule;
        }
    }

    # combine simple closures:
    # proto tcp { dport http { LOG; ACCEPT; } }
    # ->
    # proto tcp dport http { LOG; ACCEPT; }
    foreach my $rule (@result) {
        next unless exists $rule->{block} && @{$rule->{block}} == 1;

        # a block with only one item can be merged
        my $inner = $rule->{block}[0];
        delete $rule->{block};

        # merge rule
        push @{$rule->{match}}, @{$inner->{match}};
        $rule->{jump} = $inner->{jump}
          if exists $inner->{jump};
        $rule->{goto} = $inner->{goto}
          if exists $inner->{goto};
        $rule->{block} = $inner->{block}
          if exists $inner->{block};
        push @{$rule->{target} ||= []}, @{$inner->{target}}
          if exists $inner->{target};
    }

    return @result;
}

sub flush_option {
    my ($line, $key, $value) = @_;

    if (ref($value) and ref($value) eq 'pre_negated') {
        push @$line, '!';
        $value = $value->[0];
    }

    push @$line, $key;

    if (ref($value) and ref($value) eq 'negated') {
        push @$line, '!';
        $value = $value->[0];
    }

    if (ref($value) and ref($value) eq 'params') {
        foreach (@$value) {
            push @$line, format_array($_);
        }
    } elsif (defined $value) {
        push @$line, format_array($value);
    }
}

sub flush {
    # optimize and write a list of rules

    my @r = @_ ? @_ : @rules;
    @r = optimize(@r);
    foreach my $rule (@r) {
        my @line;
        # assemble the line, match stuff first, then target parameters
        if (exists $rule->{match}) {
            foreach (@{$rule->{match}}) {
                flush_option(\@line, @$_);
            }
        }

        if (exists $rule->{jump}) {
            if (is_netfilter_core_target($rule->{jump}) ||
                is_netfilter_module_target($rule->{jump})) {
                push @line, $rule->{jump};
            } else {
                flush_option(\@line, 'jump', $rule->{jump});
            }
        } elsif (exists $rule->{goto}) {
            flush_option(\@line, 'realgoto', $rule->{goto});
        } elsif (not exists $rule->{block}) {
            push @line, 'NOP';
        }

        if (exists $rule->{target}) {
            foreach (@{$rule->{target}}) {
                flush_option(\@line, @$_);
            }
        }

        if (exists $rule->{block}) {
            # this rule begins a block created in &optimize
            write_line(@line, '{');
            flush(@{$rule->{block}});
            write_line('}');
        } else {
            # just a simple rule
            write_line(@line, ';');
        }
    }
    undef @rules;
}

sub flush_domain {
    flush;
    write_line '}' if defined $chain;
    write_line '}' if defined $table;
    write_line '}' if defined $domain;

    undef $chain;
    undef $table;
    undef $domain;
}

sub tokenize {
    local $_ = shift;
    my @result;
    while (s/^\s*"([^"]+)"//s || s/^\s*(!)// || s/^\s*(\S+)//s) {
        push @result, $1;
    }
    return @result;
}

sub wrap_pre_negated {
    my ($option, $negated_ref, $value) = @_;
    return $value unless $negated_ref && $$negated_ref;

    my $wrap;
    if (grep { $_ eq $option } @pre_negated) {
        $wrap = 'pre_negated';
    } elsif (grep { $_ eq $option } @mix_negated) {
        $wrap = 'negated';
    }

    die "option '$option' in line $. cannot be pre-negated\n"
      unless defined $wrap;

    undef $$negated_ref;

    return bless [$value], $wrap;
}

sub fetch_token {
    my ($option, $tokens) = @_;
    die "not enough arguments for option '$option' in line $."
      unless @$tokens > 0;
    shift @$tokens;
}

sub fetch_token_comma {
    [ split(',', fetch_token(@_)) ]
}

sub fetch_two_tokens_comma {
    return bless [ fetch_token_comma(@_),
                   fetch_token_comma(@_) ], 'params';
}

sub wrap_negated {
    my ($option, $tokens, $fetch) = (shift, shift, shift);

    my $negated = @$tokens > 0 && $tokens->[0] eq '!' && shift @$tokens;

    die "option '$option' in line $. cannot be negated\n"
      if $negated and not grep { $_ eq $option } @negated;

    my $value = &$fetch($option, $tokens, @_);

    return bless [$value], 'negated'
      if $negated;
    return $value;
}

sub parse_option {
    my ($line, $option, $pre_negated, $tokens) = @_;

    my $cur = $line->{cur};
    die unless defined $cur;

    $option = 'destination-ports' if $option eq 'dports';
    $option = 'source-ports' if $option eq 'sports';

    if ($option eq 'protocol') {
        my $keyword = 'protocol';
        my $param = wrap_negated($keyword, $tokens, \&fetch_token);
        # protocol implicitly loads the module
        unless (ref $param) {
            my $mod = $param eq 'ipv6-icmp' ? 'icmp6' : $param;
            delete $line->{mod}{$mod};
        }
        $line->{proto} = $param;
        push @$cur, [ 'proto', $param ];
    } elsif ($option eq 'm') {
        die unless @$tokens;
        my $param = shift @$tokens;
        $line->{mod}{$param} = 1;
        # we don't need this module if the protocol with the
        # same name is already specified
        push @$cur, [ 'mod', $param ]
          unless exists $line->{proto} and
            ($line->{proto} eq $param or
             $line->{proto} =~ /^(ipv6-icmp|icmpv6)$/s and $param eq 'icmp6');
    } elsif ($option eq 'set' and exists $line->{mod}{set}) {
        push @$cur, [ $option, fetch_two_tokens_comma($option, $tokens) ];
    } elsif (exists $p0{$option}) {
        my $keyword = $p0{$option};
        push @$cur, [ $keyword, wrap_pre_negated($keyword, \$pre_negated, undef) ];
    } elsif (exists $p1{$option}) {
        my $keyword = $p1{$option};
        my $param = wrap_negated($keyword, $tokens, \&fetch_token);
        my $value = wrap_pre_negated($keyword, \$pre_negated, $param);
        unless ($keyword =~ /^[sd]addr$/ && $value eq '::/0') {
            push @$cur, [ $keyword, $value ];
        }
    } elsif (exists $p1c{$option}) {
        my $keyword = $p1c{$option};
        my $param = wrap_negated($keyword, $tokens, \&fetch_token_comma);
        push @$cur, [ $keyword, wrap_pre_negated($keyword, \$pre_negated, $param) ];
    } elsif (exists $p1multi{$option}) {
        my $keyword = $p1multi{$option};
        my $values;
        my @v = grep { $_->[0] eq $keyword } @$cur;
        if (@v == 0) {
            $values = [];
            push @$cur, [ $keyword, $values ];
        } else {
            $values = $v[0][1];
        }
        my $param = wrap_negated($keyword, $tokens, \&fetch_token);
        push @$values, wrap_pre_negated($option, \$pre_negated, $param);
    } elsif (exists $p2c{$option}) {
        my $keyword = $p2c{$option};
        my $param = wrap_negated($keyword, $tokens, \&fetch_two_tokens_comma);
        push @$cur, [ $keyword, wrap_pre_negated($keyword, \$pre_negated, $param) ];
    } elsif ($option eq 'j') {
        die unless @$tokens;
        my $target = shift @$tokens;
        # store the target in $line->{jump}
        $line->{jump} = $target;
        # what now follows is target parameters; set $cur
        # correctly
        $line->{cur} = $line->{target} = [];
    } elsif ($option eq 'g') {
        die unless @$tokens;
        my $target = shift @$tokens;
        # store the target in $line->{jump}
        $line->{goto} = $target;
    } else {
        die "option '$option' in line $. not understood\n";
    }

    die "option '$option' in line $. cannot be negated\n"
      if $pre_negated;
}

if (grep { $_ eq '-h' || $_ eq '--help' } @ARGV) {
    require Pod::Usage;
    Pod::Usage::pod2usage(-exitstatus => 0,
                          -verbose => 99);
}

if (@ARGV == 0 && -t STDIN) {
    open STDIN, "/sbin/iptables-save|"
      or die "Failed run to /sbin/iptables-save: $!";
} elsif (grep { /^-./ } @ARGV) {
    require Pod::Usage;
    Pod::Usage::pod2usage(-exitstatus => 1,
                          -verbose => 99);
}

print "# ferm rules generated by import-ferm\n";
print "# http://ferm.foo-projects.org/\n";

$next_domain = $ENV{FERM_DOMAIN} || 'ip';

my %policies;

while (<>) {
    if (/^(?:#.*)?$/) {
        # empty or comment

        $next_domain = $1 if /^#.*\b(ip|ip6)tables(?:-save)\b/;
    } elsif (/^\*(\w+)$/) {
        # table

        if (keys %policies > 0) {
            while (my ($chain, $policy) = each %policies) {
                write_line('chain', $chain, 'policy', $policy, ';');
            }
            undef %policies;
        }

        unless (defined $domain and $domain eq $next_domain) {
            flush_domain;
            $domain = $next_domain;
            write_line 'domain', $domain, '{';
        }

        write_line('}') if defined $table;
        $table = $1;
        write_line('table', $table, '{');
    } elsif (/^:(\S+)\s+-\s+/) {
        # custom chain
        die unless defined $table;
        write_line("chain $1;");
    } elsif (/^:(\S+)\s+(\w+)\s+/) {
        # built-in chain
        die unless defined $table;
        $policies{$1} = $2;
    } elsif (s/^-A (\S+)\s+//) {
        # a rule
        unless (defined $chain) {
            flush;
            $chain = $1;
            write_line('chain', $chain, '{');
        } elsif ($1 ne $chain) {
            flush;
            write_line('}');
            $chain = $1;
            write_line('chain', $chain, '{');
        }

        if (exists $policies{$chain}) {
            write_line('policy', $policies{$chain}, ';');
            delete $policies{$chain};
        }

        my @tokens = tokenize($_);

        my %line;
        # separate 'match' parameters from 'targe't parameters; $cur
        # points to the current position
        $line{cur} = $line{match} = [];
        while (@tokens) {
            local $_ = shift @tokens;
            if (/^-(\w)$/ || /^--(\S+)$/) {
                parse_option(\%line, $1, undef, \@tokens);
            } elsif ($_ eq '!') {
                die unless @tokens;
                $_ = shift @tokens;
                /^-(\w)$/ || /^--(\S+)$/
                  or die "option expected in line $.\n";
                parse_option(\%line, $1, 1, \@tokens);
            } else {
                print STDERR "warning: unknown token '$_' in line $.\n";
            }
        }
        delete $line{cur};
        push @rules, \%line;
    } elsif ($_ =~ /^COMMIT/) {
        flush;

        if (defined $chain) {
            write_line('}');
            undef $chain;
        }
    } else {
        print STDERR "line $. was not understood, ignoring it\n";
    }
}

if (keys %policies > 0) {
    while (my ($chain, $policy) = each %policies) {
        write_line('chain', $chain, 'policy', $policy, ';');
    }
}

flush_domain if defined $domain;

die unless $indent == 0;

__END__

=head1 NAME

import-ferm - import existing firewall rules into ferm

=head1 SYNOPSIS

B<import-ferm> > ferm.conf

iptables-save | B<import-ferm> > ferm.conf

B<import-ferm> I<inputfile> > ferm.conf

=head1 DESCRIPTION

This script helps you with porting an existing IPv4 firewall
configuration to ferm.  It reads a file generated with
B<iptables-save>, and tries to suggest a ferm configuration file.

If no input file was specified on the command line, B<import-ferm>
runs F<iptables-save>.

=head1 BUGS

iptables-save older than 1.3 is unable to write valid saves - this is
not a bug in B<import-ferm>.

=cut
