#!/usr/bin/perl

#
# ferm, a firewall setup program that makes firewall rules easy!
#
# Copyright (C) 2001-2007 Auke Kok, Max Kellermann
#
# Comments, questions, greetings and additions to this program
# may be sent to <ferm@foo-projects.org>
#

#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# $Id$

BEGIN {
    eval { require strict; import strict; };
    $has_strict = not $@;
    if ($@) {
        # we need no vars.pm if there is not even strict.pm
        $INC{'vars.pm'} = 1;
        *vars::import = sub {};
    } else {
        require IO::Handle;
    }

    eval { require Getopt::Long; import Getopt::Long; };
    $has_getopt = not $@;
}

use vars qw($has_strict $has_getopt);

use vars qw($DATE $VERSION);

# subversion keyword magic
$DATE = '$Date$' =~ m,(\d{4})-(\d\d)-(\d\d), ? $1.$2.$3 : '';

$VERSION = '2.0';
$VERSION .= '~svn' . $DATE;

## interface variables
# %option = command line and other options
use vars qw(%option);

## hooks
use vars qw(@pre_hooks @post_hooks);

## parser variables
# $script: current script file
# @stack = ferm's parser stack containing local variables
# $auto_chain = index for the next auto-generated chain
use vars qw($script @stack $auto_chain);

## netfilter variables
# %domains = state information about all domains ("ip" and "ip6")
# - initialized: domain initialization is done
# - tools: hash providing the paths of the domain's tools
# - previous: save file of the previous ruleset, for rollback
# - reset: has this domain already been reset?
# - tables{$name}: ferm state information about tables
#   - chains{$chain}: ferm state information about the chains
#     - builtin: whether this is a built-in chain
#     - was_created: custom chain has been created
#     - non_empty: are there rules for this chain?
use vars qw(%domains);

## constants
use vars qw(%deprecated_keywords);

# keywords from ferm 1.1 which are deprecated, and the new one; these
# are automatically replaced, and a warning is printed
%deprecated_keywords = ( goto => 'jump',
                       );

# these hashes provide the Netfilter module definitions
use vars qw(%proto_defs %match_defs %target_defs);

#
# This subsubsystem allows you to support (most) new netfilter modules
# in ferm.  Add a call to one of the "add_XY_def()" functions below.
#
# Ok, now about the cryptic syntax: the function "add_XY_def()"
# registers a new module.  There are three kinds of modules: protocol
# module (e.g. TCP, ICMP), match modules (e.g. state, physdev) and
# target modules (e.g. DNAT, MARK).
#
# The first parameter is always the module name which is passed to
# iptables with "-p", "-m" or "-j" (depending on which kind of module
# this is).
#
# After that, you add an encoded string for each option the module
# supports.  This is where it becomes tricky.
#
# foo           defaults to an option with one argument (which may be a ferm
#               array)
#
# foo*0         option without any arguments
#
# foo=s         one argument which must not be a ferm array ('s' stands for
#               'scalar')
#
# u32=m         an array which renders into multiple iptables options in one
#               rule
#
# ctstate=c     one argument, if it's an array, pass it to iptables as a
#               single comma separated value; example:
#                 ctstate (ESTABLISHED RELATED)  translates to:
#                 --ctstate ESTABLISHED,RELATED
#
# foo=sac       three arguments: scalar, array, comma separated; you may
#               concatenate more than one letter code after the '='
#
# foo&bar       one argument; call the perl function '&bar()' which parses
#               the argument
#
# !foo          negation is allowed and the '!' is written before the keyword
#
# foo!          same as above, but '!' is after the keyword and before the
#               parameters
#
# to:=to-destination    makes "to" an alias for "to-destination"; you have
#                       to add a declaration for option "to-destination"
#

# add a module definition
sub add_def_x {
    my $defs = shift;
    my $domain_family = shift;
    my $name = shift;
    die if exists $defs->{$domain_family}{$name};
    my $def = $defs->{$domain_family}{$name} = {};
    foreach (@_) {
        my $keyword = $_;
        my $k = {};

        my $params = 1;
        $params = $1 if $keyword =~ s,\*(\d+)$,,;
        $params = $1 if $keyword =~ s,=([acs]+|m)$,,;
        if ($keyword =~ s,&(\S+)$,,) {
            $params = eval "\\&$1";
            die $@ if $@;
        }
        $k->{params} = $params if $params;

        $k->{negation} = $k->{pre_negation} = 1 if $keyword =~ s,^!,,;
        $k->{negation} = 1 if $keyword =~ s,!$,,;

        $k->{alias} = $1 if $keyword =~ s,:=(\S+)$,,;

        $def->{keywords}{$keyword} = $k;
    }

    return $def;
}

# add a protocol module definition
sub add_proto_def_x(@) {
    add_def_x(\%proto_defs, @_);
}

# add a match module definition
sub add_match_def_x(@) {
    add_def_x(\%match_defs, @_);
}

# add a target module definition
sub add_target_def_x(@) {
    add_def_x(\%target_defs, @_);
}

sub add_def {
    my $defs = shift;
    add_def_x($defs, 'ip', @_);
}

# add a protocol module definition
sub add_proto_def(@) {
    add_def(\%proto_defs, @_);
}

# add a match module definition
sub add_match_def(@) {
    add_def(\%match_defs, @_);
}

# add a target module definition
sub add_target_def(@) {
    add_def(\%target_defs, @_);
}

add_proto_def 'dccp', qw(dccp-types!=c dccp-option!);
add_proto_def 'mh', qw(mh-type!);
add_proto_def 'icmp', qw(icmp-type!);
add_proto_def 'icmpv6', qw(icmpv6-type! icmp-type:=icmpv6-type);
add_proto_def 'sctp', qw(chunk-types!=sc);
add_proto_def 'tcp', qw(tcp-flags!=cc !syn*0 tcp-option! mss);
add_proto_def 'udp', qw();

add_match_def '',
  # --protocol
  qw(protocol! proto:=protocol),
  # --source, --destination
  qw(source! saddr:=source destination! daddr:=destination),
  # --in-interface
  qw(in-interface! interface:=in-interface if:=in-interface),
  # --out-interface
  qw(out-interface! outerface:=out-interface of:=out-interface),
  # --fragment
  qw(!fragment*0);
add_match_def 'account', qw(aaddr=s aname=s ashort*0);
add_match_def 'addrtype', qw(src-type dst-type);
add_match_def 'ah', qw(ahspi! ahlen! ahres*0);
add_match_def 'comment', qw(comment=s);
add_match_def 'condition', qw(condition!);
add_match_def 'connbytes', qw(!connbytes connbytes-dir connbytes-mode);
add_match_def 'connlimit', qw(!connlimit-above connlimit-mask);
add_match_def 'connmark', qw(mark);
add_match_def 'conntrack', qw(ctstate=c ctproto ctorigsrc! ctorigdst!),
  qw(ctreplsrc! ctrepldst! ctstatus ctexpire=s);
add_match_def 'dscp', qw(dscp dscp-class);
add_match_def 'ecn', qw(ecn-tcp-cwr*0 ecn-tcp-ece*0 ecn-ip-ect);
add_match_def 'esp', qw(espspi!);
add_match_def 'eui64';
add_match_def 'fuzzy', qw(lower-limit=s upper-limit=s);
add_match_def 'hbh', qw(hbh-len! hbh-opts=c);
add_match_def 'helper', qw(helper);
add_match_def 'hl', qw(hl-eq! hl-lt=s hl-gt=s);
add_match_def 'length', qw(length!);
add_match_def 'hashlimit', qw(hashlimit=s hashlimit-burst=s hashlimit-mode=s hashlimit-name=s),
  qw(hashlimit-htable-size=s hashlimit-htable-max=s),
  qw(hashlimit-htable-expire=s hashlimit-htable-gcinterval=s);
add_match_def 'iprange', qw(!src-range !dst-range);
add_match_def 'ipv6header', qw(header!=c soft*0);
add_match_def 'limit', qw(limit=s limit-burst=s);
add_match_def 'mac', qw(mac-source!);
add_match_def 'mark', qw(mark);
add_match_def 'multiport', qw(source-ports!&multiport_params),
  qw(destination-ports!&multiport_params ports!&multiport_params);
add_match_def 'nth', qw(every counter start packet);
add_match_def 'owner', qw(uid-owner gid-owner pid-owner sid-owner cmd-owner);
add_match_def 'physdev', qw(physdev-in! physdev-out!),
  qw(!physdev-is-in*0 !physdev-is-out*0 !physdev-is-bridged*0);
add_match_def 'pkttype', qw(pkt-type),
add_match_def 'policy',
  qw(dir pol strict*0 reqid spi proto mode tunnel-src tunnel-dst next*0);
add_match_def 'psd', qw(psd-weight-threshold psd-delay-threshold),
  qw(psd-lo-ports-weight psd-hi-ports-weight);
add_match_def 'quota', qw(quota=s);
add_match_def 'random', qw(average);
add_match_def 'realm', qw(realm!);
add_match_def 'recent', qw(name=s !set*0 !rcheck*0 !update*0 !seconds !hitcount rttl*0);
add_match_def 'rt', qw(rt-type! rt-segsleft! rt-len! rt-0-res*0 rt-0-addrs=c rt-0-not-strict*0);
add_match_def 'set', qw(set=sc);
add_match_def 'state', qw(state=c);
add_match_def 'statistic', qw(mode=s probability=s every=s packet=s);
add_match_def 'tcpmss', qw(!mss);
add_match_def 'time', qw(timestart=s timestop=s days=c datestart=s datestop=s);
add_match_def 'tos', qw(!tos);
add_match_def 'ttl', qw(ttl-eq ttl-lt=s ttl-gt=s);
add_match_def 'u32', qw(u32=m);

add_target_def 'BALANCE', qw(to-destination to:=to-destination);
add_target_def 'CLASSIFY', qw(set-class);
add_target_def 'CONNMARK', qw(set-mark save-mark*0 restore-mark*0 mask);
add_target_def 'CONNSECMARK', qw(save*0 restore*0);
add_target_def 'DNAT', qw(to-destination to:=to-destination);
add_target_def 'DSCP', qw(set-dscp set-dscp-class);
add_target_def 'ECN', qw(ecn-tcp-remove*0);
add_target_def 'HL', qw(hl-set hl-dec hl-inc);
add_target_def 'LOG', qw(log-level log-prefix),
  qw(log-tcp-sequence*0 log-tcp-options*0 log-ip-options*0 log-uid*0);
add_target_def 'MARK', qw(set-mark);
add_target_def 'MASQUERADE', qw(to-ports);
add_target_def 'MIRROR';
add_target_def 'NETMAP', qw(to);
add_target_def 'NFLOG', qw(nflog-group nflog-prefix nflog-range nflog-threshold);
add_target_def 'NFQUEUE', qw(queue-num);
add_target_def 'NOTRACK';
add_target_def 'REDIRECT', qw(to-ports);
add_target_def 'REJECT', qw(reject-with);
add_target_def 'ROUTE', qw(oif iif gw continue*0 tee*0);
add_target_def 'SAME', qw(to nodst*0);
add_target_def 'SECMARK', qw(selctx);
add_target_def 'SET', qw(add-set=sc del-set=sc);
add_target_def 'SNAT', qw(to-source=m to:=to-source);
add_target_def 'TARPIT';
add_target_def 'TCPMSS', qw(set-mss clamp-mss-to-pmtu*0);
add_target_def 'TOS', qw(set-tos);
add_target_def 'TRACE';
add_target_def 'TTL', qw(ttl-set ttl-dec ttl-inc);
add_target_def 'ULOG', qw(ulog-nlgroup ulog-prefix ulog-cprange ulog-qthreshold);

add_match_def_x 'arp', '',
  # ip
  qw(source-ip! destination-ip! saddr:=source-ip daddr:=destination-ip),
  # mac
  qw(source-mac! destination-mac!),
  # --in-interface
  qw(in-interface! interface:=in-interface if:=in-interface),
  # --out-interface
  qw(out-interface! outerface:=out-interface of:=out-interface),
  # misc
  qw(h-length=s opcode=s h-type=s proto-type=s),
  qw(mangle-ip-s=s mangle-ip-d=s mangle-mac-s=s mangle-mac-d=s mangle-target=s);

add_match_def_x 'eb', '',
  # protocol
  qw(protocol! proto:=protocol),
  # --in-interface
  qw(in-interface! interface:=in-interface if:=in-interface),
  # --out-interface
  qw(out-interface! outerface:=out-interface of:=out-interface),
  # logical interface
  qw(logical-in! logical-out!),
  # --source, --destination
  qw(source! saddr:=source destination! daddr:=destination),
  # 802.3
  qw(802_3-sap! 802_3-type!),
  # arp
  qw(arp-opcode! arp-htype!=ss arp-ptype!=ss),
  qw(arp-ip-src! arp-ip-dst! arp-mac-src! arp-mac-dst!),
  # ip
  qw(ip-source! ip-destination! ip-tos! ip-protocol! ip-sport! ip-dport!),
  # mark_m
  qw(mark!),
  # pkttype
  qw(pkttype-type!),
  # stp
  qw(stp-type! stp-flags! stp-root-prio! stp-root-addr! stp-root-cost!),
  qw(stp-sender-prio! stp-sender-addr! stp-port! stp-msg-age! stp-max-age!),
  qw(stp-hello-time! stp-forward-delay!),
  # vlan
  qw(vlan-id! vlan-prio! vlan-encap!),
  # log
  qw(log*0 log-level=s log-prefix=s log-ip*0 log-arp*0);

add_target_def_x 'eb', 'arpreply', qw(arpreply-mac arpreply-target);
add_target_def_x 'eb', 'dnat', qw(to-destination dnat-target);
add_target_def_x 'eb', 'mark', qw(set-mark mark-target);
add_target_def_x 'eb', 'redirect', qw(redirect-target);
add_target_def_x 'eb', 'snat', qw(to-source snat-target);

# parameter parser for ipt_multiport
sub multiport_params {
    my $fw = shift;

    # multiport only allows 15 ports at a time. For this
    # reason, we do a little magic here: split the ports
    # into portions of 15, and handle these portions as
    # array elements

    my $proto = $fw->{builtin}{protocol};
    error('To use multiport, you have to specify "proto tcp" or "proto udp" first')
      unless defined $proto and grep { /^(?:tcp|udp|udplite)$/ } to_array($proto);

    my $value = getvalues(undef, undef,
                          allow_negation => 1,
                          allow_array_negation => 1);
    if (ref $value and ref $value eq 'ARRAY') {
        my @value = @$value;
        my @params;

        while (@value) {
            push @params, join(',', splice(@value, 0, 15));
        }

        return @params == 1
          ? $params[0]
            : \@params;
    } else {
        return join_value(',', $value);
    }
}

# initialize stack: command line definitions
unshift @stack, {};

# Get command line stuff
if ($has_getopt) {
    my ($opt_noexec, $opt_flush, $opt_lines, $opt_interactive,
        $opt_verbose, $opt_debug,
        $opt_help,
        $opt_version, $opt_test, $opt_fast, $opt_shell,
        $opt_domain);

    Getopt::Long::Configure('bundling', 'auto_help', 'no_ignore_case',
                            'no_auto_abbrev');

    sub opt_def {
        my ($opt, $value) = @_;
        die 'Invalid --def specification'
          unless $value =~ /^\$?(\w+)=(.*)$/s;
        my ($name, $unparsed_value) = ($1, $2);
        my @tokens = tokenize_string($unparsed_value);
        my $value = getvalues(\&next_array_token, \@tokens);
        die 'Extra tokens after --def'
          if @tokens;
        $stack[0]{vars}{$name} = $value;
    }

    local $SIG{__WARN__} = sub { die $_[0]; };
    GetOptions('noexec|n' => \$opt_noexec,
               'flush|F' => \$opt_flush,
               'lines|l' => \$opt_lines,
               'interactive|i' => \$opt_interactive,
               'verbose|v' => \$opt_verbose,
               'debug|d' => \$opt_debug,
               'help|h' => \$opt_help,
               'version|V' => \$opt_version,
               test => \$opt_test,
               remote => \$opt_test,
               fast => \$opt_fast,
               shell => \$opt_shell,
               'domain=s' => \$opt_domain,
               'def=s' => \&opt_def,
              );

    if (defined $opt_help) {
        require Pod::Usage;
        Pod::Usage::pod2usage(-exitstatus => 0);
    }

    if (defined $opt_version) {
        printversion();
        exit 0;
    };

    $option{'noexec'} = (defined $opt_noexec);
    $option{flush} = defined $opt_flush;
    $option{'lines'} = (defined $opt_lines);
    $option{interactive} = (defined $opt_interactive);
    $option{test} = (defined $opt_test);

    if ($option{test}) {
        $option{noexec} = 1;
        $option{lines} = 1;
    }

    delete $option{interactive} if $option{noexec};

    mydie('ferm interactive mode not possible: /dev/stdin is not a tty')
      if $option{interactive} and not -t STDIN;
    mydie('ferm interactive mode not possible: /dev/stderr is not a tty')
      if $option{interactive} and not -t STDERR;

    $option{fast} = 1 if defined $opt_fast;

    if (defined $opt_shell) {
        $option{$_} = 1 foreach qw(shell fast lines);
    }

    $option{domain} = $opt_domain if defined $opt_domain;

    print STDERR "Warning: ignoring the obsolete --debug option\n"
      if defined $opt_debug;
    print STDERR "Warning: ignoring the obsolete --verbose option\n"
      if defined $opt_verbose;
} else {
    # tiny getopt emulation for microperl
    my $filename;
    foreach (@ARGV) {
        if ($_ eq '--noexec' or $_ eq '-n') {
            $option{noexec} = 1;
        } elsif ($_ eq '--lines' or $_ eq '-l') {
            $option{lines} = 1;
        } elsif ($_ eq '--fast') {
            $option{fast} = 1;
        } elsif ($_ eq '--test') {
            $option{test} = 1;
            $option{noexec} = 1;
            $option{lines} = 1;
        } elsif ($_ eq '--shell') {
            $option{$_} = 1 foreach qw(shell fast lines);
        } elsif (/^-/) {
            printf STDERR "Usage: ferm [--noexec] [--lines] [--fast] [--shell] FILENAME\n";
            exit 1;
        } else {
            $filename = $_;
        }
    }
    undef @ARGV;
    push @ARGV, $filename;
}

unless (@ARGV == 1) {
    require Pod::Usage;
    Pod::Usage::pod2usage(-exitstatus => 1);
}

if ($has_strict) {
    open LINES, ">&STDOUT" if $option{lines};
    open STDOUT, ">&STDERR" if $option{shell};
} else {
    # microperl can't redirect file handles
    *LINES = *STDOUT;

    if ($option{fast} and not $option{noexec}) {
        print STDERR "Sorry, ferm on microperl does not allow --fast without --noexec\n";
        exit 1
    }
}

unshift @stack, {};
open_script($ARGV[0]);

# parse all input recursively
enter(0);
die unless @stack == 2;

# check consistency
check();

# execute all generated rules
my $status;

foreach my $cmd (@pre_hooks) {
    print LINES "$cmd\n" if $option{lines};
    system($cmd) unless $option{noexec};
}

while (my ($domain, $domain_info) = each %domains) {
    next unless $domain_info->{enabled};
    my $s = $option{fast} &&
      defined $domain_info->{tools}{'tables-restore'}
      ? execute_fast($domain, $domain_info)
        : execute_slow($domain, $domain_info);
    $status = $s if defined $s;
}

foreach my $cmd (@post_hooks) {
    print "$cmd\n" if $option{lines};
    system($cmd) unless $option{noexec};
}

if (defined $status) {
    rollback();
    exit $status;
}

# ask user, and rollback if there is no confirmation

confirm_rules() or rollback() if $option{interactive};

exit 0;

# end of program execution!


# funcs

sub printversion {
    print "ferm $VERSION\n";
    print "Copyright (C) 2001-2007 Auke Kok, Max Kellermann\n";
    print "This program is free software released under GPLv2.\n";
    print "See the included COPYING file for license details.\n";
}


sub mydie {
    print STDERR @_;
    print STDERR "\n";
    exit 1;
}


sub error {
    # returns a nice formatted error message, showing the
    # location of the error.
    my $tabs = 0;
    my @lines;
    my $l = 0;
    my @words = map { @$_ } @{$script->{past_tokens}};

    for my $w ( 0 .. $#words ) {
        if ($words[$w] eq "\x29")
            { $l++ ; $lines[$l] = "    " x ($tabs-- -1) ;};
        if ($words[$w] eq "\x28")
            { $l++ ; $lines[$l] = "    " x $tabs++ ;};
        if ($words[$w] eq "\x7d")
            { $l++ ; $lines[$l] = "    " x ($tabs-- -1) ;};
        if ($words[$w] eq "\x7b")
            { $l++ ; $lines[$l] = "    " x $tabs++ ;};
        if ( $l > $#lines ) { $lines[$l] = "" };
        $lines[$l] .= $words[$w] . " ";
        if ($words[$w] eq "\x28")
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x29") && ($words[$w+1] ne "\x7b"))
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if ($words[$w] eq "\x7b")
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x7d") && ($words[$w+1] ne "\x7d"))
            { $l++ ; $lines[$l] = "    " x $tabs ;};
        if (($words[$w] eq "\x3b") && ($words[$w+1] ne "\x7d"))
            { $l++ ; $lines[$l] = "    " x $tabs ;}
        if ($words[$w-1] eq "option")
            { $l++ ; $lines[$l] = "    " x $tabs ;}
    }
    my $start = $#lines - 4;
    if ($start < 0) { $start = 0 } ;
    print STDERR "Error in $script->{filename} line $script->{line}:\n";
    for $l ( $start .. $#lines)
        { print STDERR $lines[$l]; if ($l != $#lines ) {print STDERR "\n"} ; };
    print STDERR "<--\n";
    mydie(@_);
}

# print a warning message about code from an input file
sub warning {
    print STDERR "Warning in $script->{filename} line $script->{line}: "
      . (shift) . "\n";
}

sub find_tool($) {
    my $name = shift;
    return $name if $option{test};
    for my $path ('/sbin', split ':', $ENV{PATH}) {
        my $ret = "$path/$name";
        return $ret if -x $ret;
    }
    die "$name not found in PATH\n";
}

sub initialize_domain {
    my $domain = shift;

    return if exists $domains{$domain}{initialized};

    die "Invalid domain '$domain'\n" unless $domain =~ /^(?:ip6?|arp|eb)$/;

    my @tools = qw(tables);
    push @tools, qw(tables-save tables-restore)
      if $domain =~ /^ip6?$/;

    # determine the location of this domain's tools
    foreach my $tool (@tools) {
        $domains{$domain}{tools}{$tool} = find_tool("${domain}${tool}");
    }

    # make tables-save tell us about the state of this domain
    # (which tables and chains do exist?), also remember the old
    # save data which may be used later by the rollback function
    local *SAVE;
    if (!$option{test} &&
        exists $domains{$domain}{tools}{'tables-save'} &&
        open(SAVE, "$domains{$domain}{tools}{'tables-save'}|")) {
        my $save = '';

        my $table_info;
        while (<SAVE>) {
            $save .= $_;

            if (/^\*(\w+)/) {
                my $table = $1;
                $table_info = $domains{$domain}{tables}{$table} ||= {};
            } elsif (defined $table_info and /^:(\w+)\s+(\S+)/
                     and $2 ne '-') {
                $table_info->{chains}{$1}{builtin} = 1;
                $table_info->{has_builtin} = 1;
            }
        }

        # for rollback
        $domains{$domain}{previous} = $save;
    }

    $domains{$domain}{initialized} = 1;
}

# split the an input string into words and delete comments
sub tokenize_string($) {
    my $string = shift;

    my @ret;

    foreach my $word ($string =~ m/(".*?"|'.*?'|`.*?`|[!,=&\$\%\(\){};]|[-+\w\/\.:]+|@\w+|#)/g) {
        last if $word eq '#';
        push @ret, $word;
    }

    return @ret;
}

# shift an array; helper function to be passed to &getvar / &getvalues
sub next_array_token {
    my $array = shift;
    shift @$array;
}

# read some more tokens from the input file into a buffer
sub prepare_tokens() {
    my $tokens = $script->{tokens};
    while (@$tokens == 0) {
        my $handle = $script->{handle};
        my $line = <$handle>;
        return unless defined $line;

        $script->{line} ++;

        my @line = tokenize_string($line);

        # the next parser stage eats this
        push @$tokens, @line;
    }

    return 1;
}

# open a ferm sub script
sub open_script($) {
    my $filename = shift;

    for (my $s = $script; defined $s; $s = $s->{parent}) {
        mydie("Circular reference in $script->{filename} line $script->{line}: $filename")
          if $s->{filename} eq $filename;
    }

    local *FILE;
    open FILE, "<$filename"
      or mydie("Failed to open $filename: $!");
    my $handle = *FILE;

    $script = { filename => $filename,
                handle => $handle,
                line => 0,
                past_tokens => [],
                tokens => [],
                parent => $script,
              };

    return $script;
}

# collect script filenames which are being included
sub collect_filenames(@) {
    my @ret;

    # determine the current script's parent directory for relative
    # file names
    die unless defined $script;
    my $parent_dir = $script->{filename} =~ m,^(.*/),
      ? $1 : './';

    foreach my $pathname (@_) {
        # non-absolute file names are relative to the parent script's
        # file name
        $pathname = $parent_dir . $pathname
          unless $pathname =~ m,^/,;

        if ($pathname =~ m,/$,) {
            # include all regular files in a directory

            error("'$pathname' is not a directory")
              unless -d $pathname;

            local *DIR;
            opendir DIR, $pathname
              or error("Failed to open directory '$pathname': $!");
            my @names = readdir DIR;
            closedir DIR;

            # sort those names for a well-defined order
            foreach my $name (sort { $a cmp $b } @names) {
                # don't include hidden and backup files
                next if /^\.|~$/;

                my $filename = $pathname . $name;
                push @ret, $filename
                  if -f $filename;
            }
        } elsif ($pathname =~ m,\|$,) {
            # run a program and use its output
            push @ret, $pathname;
        } elsif ($pathname =~ m,^\|,) {
            error('This kind of pipe is not allowed');
        } else {
            # include a regular file

            error("'$pathname' is a directory; maybe use trailing '/' to include a directory?")
              if -d $pathname;
            error("'$pathname' is not a file")
              unless -f $pathname;

            push @ret, $pathname;
        }
    }

    return @ret;
}

# peek a token from the queue, but don't remove it
sub peek_token() {
    return unless prepare_tokens();
    return $script->{tokens}[0];
}

# get a token from the queue
sub next_token() {
    return unless prepare_tokens();
    my $token = shift @{$script->{tokens}};

    # update $script->{past_tokens}
    my $past_tokens = $script->{past_tokens};

    if (@$past_tokens > 0) {
        my $prev_token = $past_tokens->[-1][-1];
        $past_tokens->[-1] = @$past_tokens > 1 ? ['{'] : []
          if $prev_token eq ';';
        pop @$past_tokens
          if $prev_token eq '}';
    }

    push @$past_tokens, [] if $token eq '{' or @$past_tokens == 0;
    push @{$past_tokens->[-1]}, $token;

    # return
    return $token;
}

# require that another token exists, and that it's not a "special"
# token, e.g. ";" and "{"
sub require_next_token {
    my $code = shift || \&next_token;

    my $token = &$code(@_);

    error('unexpected end of file')
      unless defined $token;

    error("'$token' not allowed here")
      if $token =~ /^[;{}]$/;

    return $token;
}

# return the value of a variable
sub variable_value($) {
    my $name = shift;

    foreach (@stack) {
        return $_->{vars}{$name}
          if exists $_->{vars}{$name};
    }

    return $stack[0]{auto}{$name}
      if exists $stack[0]{auto}{$name};

    return;
}

# determine the value of a variable, die if the value is an array
sub string_variable_value($) {
    my $name = shift;
    my $value = variable_value($name);

    error("variable '$name' must be a string, is an array")
      if ref $value;

    return $value;
}

# similar to the built-in "join" function, but also handle negated
# values in a special way
sub join_value($$) {
    my ($expr, $value) = @_;

    unless (ref $value) {
        return $value;
    } elsif (ref $value eq 'ARRAY') {
        return join($expr, @$value);
    } elsif (ref $value eq 'negated') {
        # bless'negated' is a special marker for negated values
        $value = join_value($expr, $value->[0]);
        return bless [ $value ], 'negated';
    } else {
        die;
    }
}

# returns the next parameter, which may either be a scalar or an array
sub getvalues {
    my ($code, $param) = (shift, shift);
    my %options = @_;

    my $token = require_next_token($code, $param);

    if ($token eq '(') {
        # read an array until ")"
        my @wordlist;

        for (;;) {
            $token = getvalues($code, $param,
                               parenthesis_allowed => 1,
                               comma_allowed => 1);

            unless (ref $token) {
                last if $token eq ')';

                if ($token eq ',') {
                    error('Comma is not allowed within arrays, please use only a space');
                    next;
                }

                push @wordlist, $token;
            } elsif (ref $token eq 'ARRAY') {
                push @wordlist, @$token;
            } else {
                error('unknown toke type');
            }
        }

        error('empty array not allowed here')
          unless @wordlist or not $options{non_empty};

        return @wordlist == 1
          ? $wordlist[0]
            : \@wordlist;
    } elsif ($token =~ /^\`(.*)\`$/s) {
        # execute a shell command, insert output
        my $command = $1;
        my $output = `$command`;
        unless ($? == 0) {
            if ($? == -1) {
                error("failed to execute: $!");
            } elsif ($? & 0x7f) {
                error("child died with signal " . ($? & 0x7f));
            } elsif ($? >> 8) {
                error("child exited with status " . ($? >> 8));
            }
        }

        # remove comments
        $output =~ s/#.*//mg;

        # tokenize
        my @tokens = grep { length } split /\s+/s, $output;

        my @values;
        while (@tokens) {
            my $value = getvalues(\&next_array_token, \@tokens);
            push @values, to_array($value);
        }

        # and recurse
        return @values == 1
          ? $values[0]
            : \@values;
    } elsif ($token =~ /^\'(.*)\'$/s) {
        # single quotes: a string
        return $1;
    } elsif ($token =~ /^\"(.*)\"$/s) {
        # double quotes: a string with escapes
        $token = $1;
        $token =~ s,\$(\w+),string_variable_value($1),eg;
        return $token;
    } elsif ($token eq '!') {
        error('negation is not allowed here')
          unless $options{allow_negation};

        $token = getvalues($code, $param);

        error('it is not possible to negate an array')
          if ref $token and not $options{allow_array_negation};

        return bless [ $token ], 'negated';
    } elsif ($token eq ',') {
        return $token
          if $options{comma_allowed};

        error('comma is not allowed here');
    } elsif ($token eq '=') {
        error('equals operator ("=") is not allowed here');
    } elsif ($token eq '$') {
        my $name = require_next_token($code, $param);
        error('variable name expected - if you want to concatenate strings, try using double quotes')
          unless $name =~ /^\w+$/;

        my $value = variable_value($name);

        error("no such variable: \$$name")
          unless defined $value;

        return $value;
    } elsif ($token eq '&') {
        error("function calls are not allowed as keyword parameter");
    } elsif ($token eq ')' and not $options{parenthesis_allowed}) {
        error('Syntax error');
    } elsif ($token =~ /^@/) {
        if ($token eq '@resolve') {
            my @params = get_function_params();
            error('Usage: @resolve((hostname ...))')
              unless @params == 1;
            eval { require Net::DNS; };
            error('For the @resolve() function, you need the Perl library Net::DNS')
              if $@;
            my $type = 'A';
            my $resolver = new Net::DNS::Resolver;
            my @result;
            foreach my $hostname (to_array($params[0])) {
                my $query = $resolver->search($hostname, $type);
                error("DNS query for '$hostname' failed: " . $resolver->errorstring)
                  unless $query;
                foreach my $rr ($query->answer) {
                    next unless $rr->type eq $type;
                    push @result, $rr->address;
                }
            }
            return \@result;
        } else {
            error("unknown ferm built-in function");
        }
    } else {
        return $token;
    }
}

# returns the next parameter, but only allow a scalar
sub getvar {
    my $token = getvalues(@_);

    error('array not allowed here')
      if ref $token and ref $token eq 'ARRAY';

    return $token;
}

sub get_function_params(%) {
    my $token = next_token();
    error('function name must be followed by "()"')
      unless defined $token and $token eq '(';

    $token = peek_token();
    if ($token eq ')') {
        require_next_token;
        return;
    }

    my @params;

    while (1) {
        if (@params > 0) {
            $token = require_next_token();
            last
              if $token eq ')';

            error('"," expected')
              unless $token eq ',';
        }

        push @params, getvalues(undef, undef, @_);
    }

    return @params;
}

# collect all tokens in a flat array reference until the end of the
# command is reached
sub collect_tokens() {
    my @level;
    my @tokens;

    while (1) {
        my $keyword = next_token();
        error('unexpected end of file within function/variable declaration')
          unless defined $keyword;

        if ($keyword =~ /^[\{\(]$/) {
            push @level, $keyword;
        } elsif ($keyword =~ /^[\}\)]$/) {
            my $expected = $keyword;
            $expected =~ tr/\}\)/\{\(/;
            my $opener = pop @level;
            error("unmatched '$keyword'")
              unless defined $opener and $opener eq $expected;
        } elsif ($keyword eq ';' and @level == 0) {
            last;
        }

        push @tokens, $keyword;

        last
          if $keyword eq '}' and @level == 0;
    }

    return \@tokens;
}


# returns the specified value as an array. dereference arrayrefs
sub to_array($) {
    my $value = shift;
    die unless wantarray;
    die if @_;
    unless (ref $value) {
        return $value;
    } elsif (ref $value eq 'ARRAY') {
        return @$value;
    } else {
        die;
    }
}

# evaluate the specified value as bool
sub eval_bool($) {
    my $value = shift;
    die if wantarray;
    die if @_;
    unless (ref $value) {
        return $value;
    } elsif (ref $value eq 'ARRAY') {
        return @$value > 0;
    } else {
        die;
    }
}

sub is_netfilter_core_target($) {
    my $target = shift;
    die unless defined $target and length $target;

    return $target =~ /^(?:ACCEPT|DROP|RETURN|QUEUE)$/;
}

sub is_netfilter_module_target($$) {
    my ($domain_family, $target) = @_;
    die unless defined $target and length $target;

    return defined $domain_family &&
      exists $target_defs{$domain_family} &&
        exists $target_defs{$domain_family}{$target};
}

sub is_netfilter_builtin_chain($$) {
    my ($table, $chain) = @_;

    return grep { $_ eq $chain }
      qw(PREROUTING INPUT FORWARD OUTPUT POSTROUTING);
}

sub netfilter_canonical_protocol($) {
    my $proto = shift;
    return 'icmpv6'
      if $proto eq 'ipv6-icmp';
    return 'mh'
      if $proto eq 'ipv6-mh';
    return $proto;
}

sub netfilter_protocol_module($) {
    my $proto = shift;
    return unless defined $proto;
    return 'icmp6'
      if $proto eq 'icmpv6';
    return $proto;
}

# escape the string in a way safe for the shell
sub shell_escape($) {
    my $token = shift;

    return $token if $token =~ /^[-_a-zA-Z0-9]+$/s;

    if ($option{fast}) {
        # iptables-save/iptables-restore are quite buggy concerning
        # escaping and special characters... we're trying our best
        # here

        $token =~ s,",',g;
        $token = '"' . $token . '"'
          if $token =~ /[\s\'\\;&]/s;
    } else {
        return $token
          if $token =~ /^\`.*\`$/;
        $token =~ s/'/\\'/g;
        $token = '\'' . $token . '\''
          if $token =~ /[\s\"\\;<>&|]/s;
    }

    return $token;
}

# append an option to the shell command line, using information from
# the module definition (see %match_defs etc.)
sub shell_append_option($$$$) {
    my ($ref, $def, $keyword, $value) = @_;

    my $negated = '';
    if (ref $value and ref $value eq 'negated') {
        $value = $value->[0];

        if (exists $def->{pre_negation}) {
            $$ref .= ' !';
        } else {
            $negated = ' !';
        }
    }

    unless (defined $value) {
        $$ref .= " --$keyword";
    } elsif (ref $value and ref $value eq 'params') {
        $$ref .= " --$keyword$negated ";
        $$ref .= join(' ', map { shell_escape($_) } @$value);
    } elsif (ref $value and ref $value eq 'multi') {
        foreach (@$value) {
            $$ref .= " --$keyword " . shell_escape($_);
        }
    } else {
        $$ref .= " --$keyword$negated " . shell_escape($value);
    }
}

# dereference a bless'negated'
sub extract_negation($) {
    local $_ = shift;
    ref && ref eq 'negated'
      ? ( '!', $_->[0] )
        : $_;
}

# convert an internal rule structure into an iptables call
sub tables($) {
    my $rule = shift;

    my $domain = $rule->{domain};
    my $domain_info = $domains{$domain};
    $domain_info->{enabled} = 1;
    my $domain_family = $rule->{domain_family};

    my $table = $rule->{table};
    my $table_info = $domain_info->{tables}{$table} ||= {};

    my $chain = $rule->{chain};
    my $chain_info = $table_info->{chains}{$chain} ||= {};
    my $chain_rules = $chain_info->{rules} ||= [];

    return if $option{flush};

    my $action = $rule->{action};

    # mark this chain as "non-empty" because we will add stuff to
    # it now; this flag is later used to check if a custom chain
    # referenced by "jump" was actually defined
    $chain_info->{non_empty} = 1;

    # check if the chain is already defined
    $chain_info->{create} = 1
      unless is_netfilter_builtin_chain($table, $chain);

    # check for unknown jump target
    $table_info->{chains}{$action->{chain}}{create} = 1
      if $action->{type} eq 'jump' or $action->{type} eq 'goto';

    # target=policy is a special case
    if ($action->{type} eq 'policy') {
        $chain_info->{policy} = $action->{policy};
        return;
    }

    # return if this is a declaration-only rule
    return
      unless $rule->{has_rule};

    my $rr = '';

    # general iptables options

    my $builtin_keywords = $match_defs{$domain_family}{''}{keywords};
    while (my ($keyword, $value) = each %{$rule->{builtin}}) {
        shell_append_option(\$rr, $builtin_keywords->{$keyword},
                            $keyword, $value);
    }

    #
    # match module options
    #

    my %modules;

    if (defined $rule->{builtin}{protocol}) {
        my $proto = $rule->{builtin}{protocol};

        # special case: --dport and --sport for TCP/UDP
        if ($domain_family eq 'ip' and
            (exists $rule->{dport} or exists $rule->{sport}) and
            $proto =~ /^(?:tcp|udp|udplite|dccp|sctp)$/) {
            unless (exists $modules{$proto}) {
                $rr .= " -m $proto";
                $modules{$proto} = 1;
            }

            shell_append_option(\$rr, { params => 1,
                                        negation => 1,
                                      }, 'dport', $rule->{dport})
              if exists $rule->{dport};
            shell_append_option(\$rr, { params => 1,
                                        negation => 1,
                                      }, 'sport', $rule->{sport})
              if exists $rule->{sport};
        }
    }

    # modules stored in %match_defs

    foreach my $match (@{$rule->{match}}) {
        my $module_name = $match->{name};
        unless (exists $modules{$module_name}) {
            $rr .= " -m $module_name";
            $modules{$module_name} = 1;
        }

        my $defs = $match->{defs};

        while (my ($keyword, $value) = each %{$match->{options}}) {
            my $def = $defs->{keywords}{$keyword};
            die unless defined $def;

            shell_append_option(\$rr, $def, $keyword, $value);
        }
    }

    #
    # target options
    #

    if ($action->{type} eq 'jump') {
        $rr .= " -j " . shell_escape($action->{chain});
    } elsif ($action->{type} eq 'goto') {
        $rr .= " -g " . shell_escape($action->{chain});
    } elsif ($action->{type} eq 'target') {
        $rr .= " -j " . shell_escape($action->{target});

        # targets stored in %target_defs

        while (my ($keyword, $value) = each %{$rule->{target_options}}) {
            my $def = $action->{defs}{keywords}{$keyword};
            die unless defined $def;

            shell_append_option(\$rr, $def, $keyword, $value);
        }
    } elsif ($action->{type} ne 'nop') {
        die;
    }

    # this line is done
    push @$chain_rules, { rule => $rr,
                          script => $rule->{script},
                        };
};

sub transform_rule($) {
    my $rule = shift;

    $rule->{builtin}{protocol} = 'icmpv6'
      if $rule->{domain} eq 'ip6' and $rule->{builtin}{protocol} eq 'icmp';
}

sub printrule($) {
    my $rule = shift;

    transform_rule($rule);

    # prints all rules in a hash
    tables($rule);
}


sub check_unfold(\@$$) {
    my ($unfold, $parent, $key) = @_;

    return unless ref $parent->{$key} and
      ref $parent->{$key} eq 'ARRAY';

    push @$unfold, $parent, $key, $parent->{$key};
}

# convert a bunch of internal rule structures in iptables calls,
# unfold arrays during that
sub mkrules($) {
    # compile the list hashes into rules
    my $fw = shift;

    my @unfold;

    foreach my $key (qw(domain table chain)) {
        check_unfold(@unfold, $fw, $key);
    }

    foreach my $key (keys %{$fw->{builtin}}) {
        check_unfold(@unfold, $fw->{builtin}, $key);
    }

    foreach my $match (@{$fw->{match}}) {
        while (my ($key, $value) = each %{$match->{options}}) {
            check_unfold(@unfold, $match->{options}, $key);
        }
    }

    check_unfold(@unfold, $fw, 'sport');
    check_unfold(@unfold, $fw, 'dport');

    if (@unfold == 0) {
        printrule($fw);
        return;
    }

    sub dofr {
        my $fw = shift;
        my ($parent, $key, $values) = (shift, shift, shift);

        foreach my $value (@$values) {
            $parent->{$key} = $value;

            if (@_) {
                dofr($fw, @_);
            } else {
                printrule($fw);
            }
        }
    }

    dofr($fw, @unfold);
}

sub filter_domains($) {
    my $domains = shift;
    my $result = [];

    foreach my $domain (to_array $domains) {
        next if exists $option{domain}
          and $domain ne $option{domain};

        eval {
            initialize_domain($domain);
        };
        error($@) if $@;

        push @$result, $domain;
    }

    return @$result == 1 ? $result->[0] : $result;
}

# parse tokens from builtin match modules
sub parse_builtin_matches($$$) {
    my ($current, $keyword, $negated_ref) = @_;

    my $domain_family = $current->{domain_family};

    if (exists $match_defs{$domain_family}) {
        parse_option('', $match_defs{$domain_family}{''},
                     $current, $current->{builtin},
                     $keyword, $negated_ref)
          and return 1;
    }

    return;
}

# parse a keyword from a module definition
sub parse_keyword($$$$) {
    my ($current, $def, $keyword, $negated_ref) = @_;

    my $params = $def->{params};

    my $value;

    my $negated;
    if ($$negated_ref && exists $def->{pre_negation}) {
        $negated = 1;
        undef $$negated_ref;
    }

    unless (defined $params) {
        undef $value;
    } elsif (ref $params && ref $params eq 'CODE') {
        $value = &$params($current);
    } elsif ($params eq 'm') {
        $value = bless [ to_array getvalues() ], 'multi';
    } elsif ($params =~ /^[a-z]/) {
        if (exists $def->{negation} and not $negated) {
            my $token = peek_token();
            if ($token eq '!') {
                require_next_token;
                $negated = 1;
            }
        }

        my @params;
        foreach my $p (split(//, $params)) {
            if ($p eq 's') {
                push @params, getvar();
            } elsif ($p eq 'c') {
                my @v = to_array getvalues(undef, undef,
                                           non_empty => 1);
                push @params, join(',', @v);
            } else {
                die;
            }
        }

        $value = @params == 1
          ? $params[0]
            : bless \@params, 'params';
    } elsif ($params == 1) {
        if (exists $def->{negation} and not $negated) {
            my $token = peek_token();
            if ($token eq '!') {
                require_next_token;
                $negated = 1;
            }
        }

        $value = getvalues();

        warning("log-prefix is too long; truncating to 29 characters: '$1'")
          if $keyword eq 'log-prefix' && $value =~ s,^(.{29}).+$,$1,;
    } else {
        if (exists $def->{negation} and not $negated) {
            my $token = peek_token();
            if ($token eq '!') {
                require_next_token;
                $negated = 1;
            }
        }

        $value = bless [ map {
            getvar()
        } (1..$params) ], 'params';
    }

    $value = bless [ $value ], 'negated'
      if $negated;

    return $value;
}

# parse options of a module
sub parse_option($$$$$$) {
    my ($name, $def, $current, $store, $keyword, $negated_ref) = @_;

    my $k = $def->{keywords}{$keyword};
    return unless defined $k;

    while (exists $k->{alias}) {
        die if $k->{alias} eq $keyword;
        $keyword = $k->{alias};
        $k = $def->{keywords}{$keyword};
        die unless defined $k;
    }

    $store->{$keyword}
      = parse_keyword($current, $k,
                      $keyword, $negated_ref);
    $current->{has_rule} = 1;
    return 1;
}

# parse options for a protocol module definition
sub parse_protocol_options($$$$) {
    my ($current, $proto, $keyword, $negated_ref) = @_;

    my $domain_family = $current->{'domain_family'};
    my $proto_defs = $proto_defs{$domain_family};
    return unless defined $proto_defs;

    my $proto_def = $proto_defs->{$proto};
    return unless defined $proto_def and
      exists $proto_def->{keywords}{$keyword};

    my $module_name = $proto eq 'icmpv6' ? 'icmp6' : $proto;
    my $module = { name => $module_name,
                   options => {},
                   defs => $proto_def,
                 };
    push @{$current->{match}}, $module;

    return parse_option($proto, $proto_def,
                        $current, $module->{options},
                        $keyword, $negated_ref);
}

# parse options for a match module definition
sub parse_module_options($$$) {
    my ($current, $keyword, $negated_ref) = @_;

    # modules stored in %match_defs
    foreach my $module (@{$current->{match}}) {
        my $def = $module->{defs};
        next unless defined $def;

        parse_option($module->{name}, $def,
                     $current, $module->{options},
                     $keyword, $negated_ref)
          and do {
              # reset hash
              keys %{$module->{defs}};
              return 1;
          }
    }

    return;
}

# parse options for a target module definition
sub parse_target_options($$$) {
    my ($current, $target, $keyword) = @_;

    my $target_defs = $current->{action}{defs};
    return unless defined $target_defs &&
      exists $target_defs->{keywords}{$keyword};

    my $k = $target_defs->{keywords}{$keyword};

    while (exists $k->{alias}) {
        die if $k->{alias} eq $keyword;
        $keyword = $k->{alias};
        $k = $target_defs->{keywords}{$keyword};
        die unless defined $k;
    }

    my $negated_dummy;
    $current->{target_options}{$keyword}
      = parse_keyword($current, $k,
                      $keyword, \$negated_dummy);

    return 1;
}

sub clone_match($) {
    my $match = shift;
    return { name => $match->{name},
             options => { %{$match->{options}} },
             defs => $match->{defs},
           };
}

sub new_level(\%$) {
    my ($current, $prev) = @_;

    %$current = ();
    if (defined $prev) {
        # copy data from previous level
        $current->{builtin} = { %{$prev->{builtin}} };
        $current->{match} = [ map { clone_match($_) } @{$prev->{match}} ];
        $current->{action} = { %{$prev->{action}} };
        foreach my $key (qw(domain domain_family table chain proto sport dport)) {
            $current->{$key} = $prev->{$key}
              if exists $prev->{$key};
        }
    } else {
        $current->{builtin} = {};
        $current->{match} = [];
        $current->{action} = {};
    }
}

sub rule_defined(\%) {
    my $rule = shift;
    return defined($rule->{domain}) or
      keys(%{$rule->{builtin}}) > 0 or
      keys(%{$rule->{match}}) > 0 or
      keys(%{$rule->{action}}) > 0;
}

# the main parser loop: read tokens, convert them into internal rule
# structures
sub enter($$) {
    my $lev = shift;  # current recursion depth
    my $prev = shift; # previous rule hash

    # enter is the core of the firewall setup, it is a
    # simple parser program that recognizes keywords and
    # retreives parameters to set up the kernel routing
    # chains

    my $base_level = $script->{base_level} || 0;
    die if $base_level > $lev;

    my %current;
    new_level(%current, $prev);

    # read keywords 1 by 1 and dump into parser
    while (defined (my $keyword = next_token())) {
        # check if the current rule should be negated
        my $negated = $keyword eq '!';
        if ($negated) {
            # negation. get the next word which contains the 'real'
            # rule
            $keyword = getvar();

            error('unexpected end of file after negation')
              unless defined $keyword;
        }

        # the core: parse all data
        SWITCH: for ($keyword)
        {
            # deprecated keyword?
            if (exists $deprecated_keywords{$keyword}) {
                my $new_keyword = $deprecated_keywords{$keyword};
                warning("'$keyword' is deprecated, please use '$new_keyword' instead");
                $keyword = $new_keyword;
            }

            # effectuation operator
            if ($keyword eq ';') {
                if ($current{has_rule} and not $current{action}{type}) {
                    # something is wrong when a rule was specifiedd,
                    # but no action
                    error('No action defined; did you mean "NOP"?');
                }

                error('No chain defined') unless defined $current{chain};

                $current{script} = { filename => $script->{filename},
                                     line => $script->{line},
                                   };

                mkrules(\%current);

                # and clean up variables set in this level
                new_level(%current, $prev);

                next;
            }

            # conditional expression
            if ($keyword eq '@if') {
                unless (eval_bool(getvalues)) {
                    collect_tokens;
                    my $token = peek_token();
                    require_next_token() if $token and $token eq '@else';
                }

                next;
            }

            if ($keyword eq '@else') {
                # hack: if this "else" has not been eaten by the "if"
                # handler above, we believe it came from an if clause
                # which evaluated "true" - remove the "else" part now.
                collect_tokens;
                next;
            }

            # hooks for custom shell commands
            if ($keyword eq 'hook') {
                error('"hook" must be the first token in a command')
                  if rule_defined(%current);

                my $position = getvar();
                my $hooks;
                if ($position eq 'pre') {
                    $hooks = \@pre_hooks;
                } elsif ($position eq 'post') {
                    $hooks = \@post_hooks;
                } else {
                    error("Invalid hook position: '$position'");
                }

                push @$hooks, getvar();

                $keyword = next_token();
                error('";" expected after hook declaration')
                  unless defined $keyword and $keyword eq ';';

                next;
            }

            # recursing operators
            if ($keyword eq '{') {
                # push stack
                my $old_stack_depth = @stack;

                unshift @stack, { auto => { %{$stack[0]{auto} || {}} } };

                # recurse
                enter($lev + 1, \%current);

                # pop stack
                shift @stack;
                die unless @stack == $old_stack_depth;

                # after a block, the command is finished, clear this
                # level
                new_level(%current, $prev);

                next;
            }

            if ($keyword eq '}') {
                error('Unmatched "}"')
                  if $lev <= $base_level;

                # consistency check: check if they havn't forgotten
                # the ';' before the last statement
                error('Missing semicolon before "}"')
                  if $current{has_rule};

                # and exit
                return;
            }

            # include another file
            if ($keyword eq '@include' or $keyword eq 'include') {
                my @files = collect_filenames to_array getvalues;
                $keyword = next_token;
                error('Missing ";" - "include FILENAME" must be the last command in a rule')
                  unless defined $keyword and $keyword eq ';';

                foreach my $filename (@files) {
                    # save old script, open new script
                    my $old_script = $script;
                    open_script($filename);
                    $script->{base_level} = $lev + 1;

                    # push stack
                    my $old_stack_depth = @stack;

                    my $stack = {};

                    if (@stack > 0) {
                        # include files may set variables for their parent
                        $stack->{vars} = ($stack[0]{vars} ||= {});
                        $stack->{functions} = ($stack[0]{functions} ||= {});
                        $stack->{auto} = { %{ $stack[0]{auto} || {} } };
                    }

                    unshift @stack, $stack;

                    # parse the script
                    enter($lev + 1, \%current);

                    # pop stack
                    shift @stack;
                    die unless @stack == $old_stack_depth;

                    # restore old script
                    $script = $old_script;
                }

                next;
            }

            # definition of a variable or function
            if ($keyword eq '@def' or $keyword eq 'def') {
                error('"def" must be the first token in a command')
                  if $current{has_rule};

                my $type = require_next_token();
                if ($type eq '$') {
                    my $name = require_next_token();
                    error('invalid variable name')
                      unless $name =~ /^\w+$/;

                    $keyword = require_next_token();
                    error('"=" expected after variable name')
                      unless $keyword eq '=';

                    my $value = getvalues(undef, undef, allow_negation => 1);

                    $keyword = next_token();
                    error('";" expected after variable declaration')
                      unless defined $keyword and $keyword eq ';';

                    $stack[0]{vars}{$name} = $value
                      unless exists $stack[-1]{vars}{$name};
                } elsif ($type eq '&') {
                    my $name = require_next_token();
                    error('invalid function name')
                      unless $name =~ /^\w+$/;

                    my @params;
                    my $token = next_token();
                    error('function parameter list or "()" expected')
                      unless defined $token and $token eq '(';
                    while (1) {
                        $token = require_next_token();
                        last if $token eq ')';

                        if (@params > 0) {
                            error('"," expected')
                              unless $token eq ',';

                            $token = require_next_token();
                        }

                        error('"$" and parameter name expected')
                          unless $token eq '$';

                        $token = require_next_token();
                        error('invalid function parameter name')
                          unless $token =~ /^\w+$/;

                        push @params, $token;
                    }

                    my %function;

                    $function{params} = \@params;

                    $keyword = require_next_token;
                    error('"=" expected')
                      unless $keyword eq '=';

                    my $tokens = collect_tokens();
                    $function{block} = 1 if grep { $_ eq '{' } @$tokens;
                    $function{tokens} = $tokens;

                    $stack[0]{functions}{$name} = \%function
                      unless exists $stack[-1]{functions}{$name};
                } else {
                    error('"$" (variable) or "&" (function) expected');
                }

                next;
            }

            # def references
            if ($keyword eq '$') {
                error('variable references are only allowed as keyword parameter');
            }

            if ($keyword eq '&') {
                my $name = require_next_token;
                error('function name expected')
                  unless $name =~ /^\w+$/;

                my $function;
                foreach (@stack) {
                    $function = $_->{functions}{$name};
                    last if defined $function;
                }
                error("no such function: \&$name")
                  unless defined $function;

                my $paramdef = $function->{params};
                die unless defined $paramdef;

                my @params = get_function_params(allow_negation => 1);

                error("Wrong number of parameters for function '\&$name': "
                      . @$paramdef . " expected, " . @params . " given")
                  unless @params == @$paramdef;

                my %vars;
                for (my $i = 0; $i < @params; $i++) {
                    $vars{$paramdef->[$i]} = $params[$i];
                }

                if ($function->{block}) {
                    # block {} always ends the current rule, so if the
                    # function contains a block, we have to require
                    # the calling rule also ends here
                    my $token = next_token();
                    error("';' expected after block function call '\&$name'")
                      unless defined $token and $token eq ';';
                }

                my @tokens = @{$function->{tokens}};
                for (my $i = 0; $i < @tokens; $i++) {
                    if ($tokens[$i] eq '$' and $i + 1 < @tokens and
                        exists $vars{$tokens[$i + 1]}) {
                        my @value = to_array($vars{$tokens[$i + 1]});
                        @value = ('(', @value, ')')
                          unless @tokens == 1;
                        splice(@tokens, $i, 2, @value);
                        $i += @value - 2;
                    } elsif ($tokens[$i] =~ m,^"(.*)"$,) {
                        $tokens[$i] =~ s,\$(\w+),exists $vars{$1} ? $vars{$1} : "\$$1",eg;
                    }
                }

                unshift @{$script->{tokens}}, @tokens;

                next;
            }

            # where to put the rule?
            if ($keyword eq 'domain') {
                error('Domain is already specified')
                  if exists $current{domain};

                my $domain = getvalues();
                my $filtered_domain = filter_domains($domain);
                my $domain_family;
                unless (ref $domain) {
                    $domain_family = $domain eq 'ip6' ? 'ip' : $domain;
                } elsif (@$domain == 0) {
                    $domain_family = 'none';
                } elsif (grep { not /^ip6?$/s } @$domain) {
                    error('Cannot combine non-IP domains');
                } else {
                    $domain_family = 'ip';
                }
                $current{domain_family} = $domain_family;

                $current{domain} = $stack[0]{auto}{DOMAIN} = $filtered_domain;

                next;
            }

            if ($keyword eq 'table') {
                error('Table is already specified')
                  if exists $current{table};
                $current{table} = $stack[0]{auto}{TABLE} = getvalues();

                unless (exists $current{domain}) {
                    $current{domain} = filter_domains('ip');
                    $current{domain_family} = 'ip';
                }

                next;
            }

            if ($keyword eq 'chain') {
                error('Chain is already specified')
                  if exists $current{chain};
                $current{chain} = $stack[0]{auto}{CHAIN} = getvalues();

                # ferm 1.1 allowed lower case built-in chain names
                foreach (ref $current{chain} ? @{$current{chain}} : $current{chain}) {
                    error('Please write built-in chain names in upper case')
                      if /^(?:input|forward|output|prerouting|postrouting)$/;
                }

                unless (exists $current{domain}) {
                    $current{domain} = filter_domains('ip');
                    $current{domain_family} = 'ip';
                }

                $current{table} = 'filter'
                  unless exists $current{table};

                next;
            }

            error('Chain must be specified')
              unless exists $current{chain};

            # policy for built-in chain
            if ($keyword eq 'policy') {
                error('Cannot specify matches for policy')
                  if $current{has_rule};

                my $policy = uc getvar();
                error("Invalid policy target: $policy")
                  unless $policy =~ /^(?:ACCEPT|DROP)$/;

                $keyword = peek_token();
                error('";" expected after policy declaration')
                  unless defined $keyword and $keyword eq ';';

                $current{action} = { type => 'policy',
                                     policy => $policy,
                                   };
                next;
            }

            # create a subchain
            if ($keyword eq '@subchain' or $keyword eq 'subchain') {
                error('No rule specified before "@subchain"')
                  unless $current{has_rule};

                my $subchain;
                $keyword = next_token();

                if ($keyword =~ /^(["'])(.*)\1$/s) {
                    $subchain = $2;
                    $keyword = next_token();
                } else {
                    $subchain = 'ferm_auto_' . ++$auto_chain;
                }

                error('"{" or chain name expected after "sub"')
                  unless $keyword eq '{';

                # create a deep copy of %current, only containing values
                # which must be in the subchain
                my %inner = ( builtin => {},
                              action => {},
                            );
                $inner{domain} = $current{domain};
                $inner{domain_family} = $current{domain_family};
                $inner{table} = $current{table};
                $inner{chain} = $inner{auto}{CHAIN} = $subchain;
                $inner{builtin}{protocol} = $current{builtin}{protocol}
                  if exists $current{builtin}{protocol};

                # enter the block
                enter(1, \%inner);

                # now handle the parent - it's a jump to the sub chain
                $current{action} = { type => 'jump',
                                     chain => $subchain,
                                   };

                $current{script} = { filename => $script->{filename},
                                     line => $script->{line},
                                   };

                mkrules(\%current);

                # and clean up variables set in this level
                new_level(%current, $prev);

                next;
            }

            # everything else must be part of a "real" rule, not just
            # "policy only"
            $current{has_rule}++;

            # extended parameters:
            if ($keyword =~ /^mod(?:ule)?$/) {
                foreach my $module (to_array getvalues) {
                    next if grep { $_->{name} eq $module } @{$current{match}};

                    my $domain_family = $current{domain_family};
                    my $defs = $match_defs{$domain_family}{$module};
                    if (not defined $defs and exists $current{builtin}{protocol}) {
                        my $proto = $current{builtin}{protocol};
                        unless (ref $proto) {
                            $proto = netfilter_canonical_protocol($current{builtin}{protocol});
                            $defs = $proto_defs{$domain_family}{$proto}
                              if netfilter_protocol_module($proto) eq $module;
                        }
                    }

                    push @{$current{match}}, { name => $module,
                                               options => {},
                                               defs => $defs,
                                             };
                }

                next;
            }

            parse_builtin_matches(\%current, $keyword, \$negated)
              and next;

            ###
            # actions
            #

            # jump action
            if ($keyword eq 'jump') {
                error('There can only one action per rule')
                  if defined $current{action}{type};
                my $chain = getvar();
                if (is_netfilter_core_target($chain) or
                    is_netfilter_module_target($current{domain_family}, $chain)) {
                    my $defs = $target_defs{$current{domain_family}} &&
                      $target_defs{$current{domain_family}}{$chain};
                    $current{action} = { type => 'target',
                                         target => $chain,
                                         defs => $defs,
                                       };
                } else {
                    $current{action} = { type => 'jump',
                                         chain => $chain,
                                       };
                }
                next;
            };

            # goto action
            if ($keyword eq 'realgoto') {
                error('There can only one action per rule')
                  if defined $current{action}{type};
                $current{action} = { type => 'goto',
                                     chain => getvar(),
                                   };
                next;
            };

            # action keywords
            if (is_netfilter_core_target($keyword)) {
                error('There can only one action per rule')
                  if defined $current{action}{type};
                $current{action} = { type => 'target',
                                     target => $keyword,
                                   };
                next;
            }

            if ($keyword eq 'NOP') {
                error('There can only one action per rule')
                  if defined $current{action}{type};
                $current{action} = { type => 'nop',
                                   };
                next;
            }

            if (is_netfilter_module_target($current{domain_family}, $keyword)) {
                error('There can only one action per rule')
                  if defined $current{action}{type};

                if ($keyword eq 'TCPMSS') {
                    my $protos = $current{builtin}{protocol};
                    error('No protocol specified before TCPMSS')
                      unless defined $protos;
                    foreach my $proto (to_array $protos) {
                        error('TCPMSS not available for protocol "$proto"')
                          unless $proto eq 'tcp';
                    }
                }

                $current{action} = { type => 'target',
                                     target => $keyword,
                                     defs => $target_defs{$current{domain_family}}{$keyword},
                                   };
                next;
            }

            my $proto = $current{builtin}{protocol};

            ###
            # module specific options
            #

            parse_module_options(\%current, $keyword, \$negated)
              and next;

            ###
            # protocol specific options
            #

            if (defined $proto and not ref $proto) {
                $proto = netfilter_canonical_protocol($proto);

                if ($proto eq 'icmp') {
                    my $domains = $current{domain};
                    $proto = 'icmpv6' if not ref $domains and $domains eq 'ip6';
                }

                parse_protocol_options(\%current, $proto, $keyword, \$negated)
                  and next;
            }

            # port switches
            if ($keyword =~ /^[sd]port$/) {
                error('To use sport or dport, you have to specify "proto tcp" or "proto udp" first')
                  unless defined $proto and grep { /^(?:tcp|udp|udplite|dccp|sctp)$/ } to_array $proto;

                $current{$keyword} = getvalues(undef, undef,
                                               allow_negation => 1);
                next;
            }

            ###
            # target specific options
            #

            if (exists $current{action}{type} and
                $current{action}{type} eq 'target') {
                parse_target_options(\%current, $current{action}{target},
                                     $keyword);
                next;
            }

            # default
            error("Unrecognized keyword: $keyword");
        }

        # if the rule didn't reset the negated flag, it's not
        # supported
        error("Doesn't support negation: $keyword")
          if $negated;
    }

    error('Missing "}" at end of file')
      if $lev > $base_level;

    # consistency check: check if they havn't forgotten
    # the ';' before the last statement
    error("Missing semicolon before end of file")
      if $current{has_rule}; # XXX
}

sub check() {
    while (my ($domain_name, $domain) = each %domains) {
        while (my ($table_name, $table_info) = each %{$domain->{tables}}) {
            while (my ($chain_name, $chain) = each %{$table_info->{chains}}) {
                warning("chain $chain_name (domain $domain_name, table $table_name) was referenced, but not declared")
                  if $chain->{was_created} and not $chain->{non_empty};
            }
        }
    }
}

sub execute_command {
    my ($command, $script) = @_;

    print LINES "$command\n"
      if $option{lines};
    return if $option{noexec};

    my $ret = system($_);
    unless ($ret == 0) {
        if ($? == -1) {
            print STDERR "failed to execute: $!\n";
            exit 1;
        } elsif ($? & 0x7f) {
            printf STDERR "child died with signal %d\n", $? & 0x7f;
            return 1;
        } else {
            print STDERR "(rule declared in $script->{filename}:$script->{line})\n"
              if defined $script;
            return $? >> 8;
        }
    }

    return;
}

sub execute_slow($$) {
    my ($domain, $domain_info) = @_;

    my $domain_cmd = $domain_info->{tools}{tables};

    while (my ($table, $table_info) = each %{$domain_info->{tables}}) {
        my $table_cmd = "$domain_cmd -t $table";

        # reset chain policies
        while (my ($chain, $chain_info) = each %{$table_info->{chains}}) {
            next unless $chain_info->{builtin} or
              (not $table_info->{has_builtin} and
               is_netfilter_builtin_chain($table, $chain));
            $status ||= execute_command("$table_cmd -P $chain ACCEPT");
        }

        # clear
        $status ||= execute_command("$table_cmd -F");
        $status ||= execute_command("$table_cmd -X");

        # create chains / set policy
        while (my ($chain, $chain_info) = each %{$table_info->{chains}}) {
            if ($chain_info->{create}) {
                $status ||= execute_command("$table_cmd -N $chain");
            } elsif (exists $chain_info->{policy}) {
                $status ||= execute_command("$table_cmd -P $chain $chain_info->{policy}");
            }
        }

        # dump rules
        while (my ($chain, $chain_info) = each %{$table_info->{chains}}) {
            my $chain_cmd = "$table_cmd -A $chain";
            foreach my $rule (@{$chain_info->{rules}}) {
                $status ||= execute_command($chain_cmd . $rule->{rule});
            }
        }
    }

    return $status;
}

sub rules_to_save($$) {
    my ($domain, $domain_info) = @_;

    # convert this into an iptables-save text
    my $result = "# Generated by ferm $VERSION on " . localtime() . "\n";

    while (my ($table, $table_info) = each %{$domain_info->{tables}}) {
        # select table
        $result .= '*' . $table . "\n";

        # create chains / set policy
        foreach my $chain (sort keys %{$table_info->{chains}}) {
            my $chain_info = $table_info->{chains}{$chain};
            my $policy = $chain_info->{create}
              ? '-' : ($chain_info->{policy} || 'ACCEPT');
            $result .= ":$chain $policy\ [0:0]\n";
        }

        # dump rules
        foreach my $chain (sort keys %{$table_info->{chains}}) {
            my $chain_info = $table_info->{chains}{$chain};
            foreach my $rule (@{$chain_info->{rules}}) {
                $result .= "-A $chain$rule->{rule}\n";
            }
        }

        # do it
        $result .= "COMMIT\n";
    }

    return $result;
}

sub restore_domain($$) {
    my ($domain, $save) = @_;

    my $path = $domains{$domain}{tools}{'tables-restore'};

    local *RESTORE;
    open RESTORE, "|$path"
      or die "Failed to run $path: $!\n";

    print RESTORE $save;

    close RESTORE
      or die "Failed to run $path\n";
}

sub execute_fast($$) {
    my ($domain, $domain_info) = @_;

    my $save = rules_to_save($domain, $domain_info);

    if ($option{lines}) {
        print LINES "$domain_info->{tools}{'tables-restore'} <<EOT\n"
          if $option{shell};
        print LINES $save;
        print LINES "EOT\n"
          if $option{shell};
    }

    return if $option{noexec};

    eval {
        restore_domain($domain, $save);
    };
    if ($@) {
        print STDERR $@;
        return 1;
    }

    return;
}

sub rollback() {
    my $error;
    while (my ($domain, $domain_info) = each %domains) {
        next unless $domain_info->{enabled};
        unless (defined $domain_info->{tools}{'tables-restore'}) {
            print STDERR "Cannot rollback domain '$domain' because there is no ${domain}tables-restore\n";
            next;
        }

        my $reset = '';
        while (my ($table, $table_info) = each %{$domain_info->{tables}}) {
            my $reset_chain = '';
            foreach my $chain (keys %{$table_info->{chains}{$table}}) {
                next unless is_netfilter_builtin_chain($table, $chain);
                $reset_chain .= ":${chain} ACCEPT [0:0]\n";
            }
            $reset .= "*${table}\n${reset_chain}COMMIT\n"
              if length $reset_chain;
        }

        $reset .= $domain_info->{previous}
          if defined $domain_info->{previous};

        restore_domain($domain, $reset);
    }

    print STDERR "\nFirewall rules rolled back.\n" unless $error;
    exit 1;
}

sub alrm_handler {
    # do nothing, just interrupt a system call
}

sub confirm_rules() {
    $SIG{ALRM} = \&alrm_handler;

    alarm(5);

    print STDERR "\n"
      . "ferm has applied the new firewall rules.\n"
        . "Please type 'yes' to confirm:\n";
    STDERR->flush();

    alarm(30);

    my $line = '';
    STDIN->sysread($line, 3);

    eval {
        require POSIX;
        POSIX::tcflush(*STDIN, 2);
    };
    print STDERR "$@" if $@;

    $SIG{ALRM} = 'DEFAULT';

    return $line eq 'yes';
}

# end of ferm

__END__

=head1 NAME

ferm - a firewall rule parser for linux

=head1 SYNOPSIS

B<ferm> I<options> I<inputfiles>

=head1 OPTIONS

 -n, --noexec      Do not execute the rules, just simulate
 -F, --flush       Flush all netfilter tables managed by ferm
 -l, --lines       Show all rules that were created
 -i, --interactive Interactive mode: revert if user does not confirm
 --remote          Remote mode; ignore host specific configuration.
                   This implies --noexec and --lines.
 -V, --version     Show current version number
 -h, --help        Look at this text
 --fast            Generate an iptables-save file, used by iptables-restore
 --shell           Generate a shell script which calls iptables-restore
 --domain {ip|ip6} Handle only the specified domain
 --def '$name=v'   Override a variable

=cut
